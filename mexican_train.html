<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mexican Train Domino - Neon Night Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #00ff9d;
            overflow-x: hidden; 
            min-height: 100vh;
        }

        /* Prevent scrollbars during dealing animation - IMPROVED VERSION */
        html.dealing,
        body.dealing {
            overflow: hidden !important;
            position: fixed !important;
            width: 100vw !important;
            height: 100vh !important;
        }

        /* Hide all scrollbars during dealing */
        html.dealing::-webkit-scrollbar,
        body.dealing::-webkit-scrollbar,
        .dealing *::-webkit-scrollbar {
            display: none !important;
        }

        html.dealing,
        body.dealing {
            scrollbar-width: none !important;
            -ms-overflow-style: none !important;
        }

        /* Make dealing tiles not affect layout */
        .domino.deal-animation {
            position: absolute !important;
            z-index: 9999 !important;
        }

        .player-hand.dealing {
            overflow: hidden !important;
            position: relative !important;
        }

        /* Grid background pattern */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 157, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 157, 0.03) 1px, transparent 1px);
            background-size: 30px 30px;
            pointer-events: none;
            z-index: 0;
        }

        .game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            z-index: 1;
        }

        /* Header */
        .game-header {
            padding: 15px 20px;
            background: rgba(26, 26, 46, 0.9);
            border-bottom: 2px solid #00ff9d;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            position: relative;
            z-index: 10; /* Ensure header is above other elements */
        }

        .game-title {
            font-size: 1.8em;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff9d, 0 0 20px #00ff9d;
            letter-spacing: 2px;
            flex-shrink: 0;
        }

        .game-info {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .header-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-shrink: 0;
        }

        .info-item {
            font-size: 0.95em;
            color: #00ffff;
            text-shadow: none;
        }

        .info-label {
            color: #888;
            margin-right: 5px;
        }

        /* Trains area (top 60%) */
        .trains-area {
            flex: 6;
            padding: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .train-lane {
            flex: 1;
            background: rgba(20, 20, 35, 0.6);
            border: 1px solid rgba(0, 255, 157, 0.2);
            border-radius: 8px;
            padding: 12px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 15px;
        }

        .train-lane.playable {
            border-color: #00ff9d;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.4);
            background: rgba(0, 255, 157, 0.05);
        }

        .train-lane.mexican-train {
            border-color: #ff00ff;
        }

        .train-lane.mexican-train.playable {
            border-color: #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
            background: rgba(255, 0, 255, 0.05);
        }

        .train-lane.drop-target {
            background: rgba(0, 255, 157, 0.15);
            border-color: #00ff9d;
            box-shadow: 0 0 30px rgba(0, 255, 157, 0.6);
        }

        .train-info {
            min-width: 170px;
            max-width: 170px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-left: 8px;
        }

        .train-name {
            font-size: 0.95em;
            font-weight: bold;
            color: #00ffff;
            text-shadow: none;
            white-space: nowrap;
            margin-left: -8px;
        }

        .mexican-train .train-name {
            color: #ff00ff;
            text-shadow: none;
            margin-left: -25px;
        }

        .train-status {
            font-size: 0.8em;
            color: #888;
            margin-top: 0; 
            margin-left: 40px; 
        }

        .train-public {
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }

        .train-tile-count {
            font-size: 0.8em;
            color: #888;
        }

        .engine-start {
            min-width: 40px;
            max-width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff00ff 0%, #8b00ff 100%);
            box-shadow: 0 0 15px #ff00ff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1em;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .engine-start.hidden {
            opacity: 0;
            width: 0;
            min-width: 0;
            max-width: 0;
            margin: 0;
            overflow: hidden;
        }
    

        .train-tiles {
        
        display: flex;
        gap: 8px;
        align-items: center;
        flex: 1;
        overflow-x: auto;
        overflow-y: hidden;
        padding: 5px 0;
        padding-top: 10px;
        padding-bottom: 10px;
        scroll-behavior: smooth;
        }

        .train-tiles::-webkit-scrollbar {
            height: 4px;
        }

        .train-tiles::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        .train-tiles::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 157, 0.5);
            border-radius: 2px;
        }
        /* Auto-scroll behavior */
        .train-tiles.auto-scrolling {
            scroll-behavior: smooth;
        }
        
        /* Enhanced tile slide-in animation with impact */
        .domino.tile-slide-in {
            animation: dominoLand 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        
        @keyframes dominoLand {
            0% {
                transform: translateX(50px) scale(0.8) rotateY(-15deg);
                opacity: 0;
                filter: brightness(1.8);
            }
            60% {
                transform: translateX(0) scale(1.15) rotateY(5deg);
            }
            80% {
                transform: scale(0.95) rotateY(-2deg);
            }
            100% {
                transform: scale(1) rotateY(0);
                opacity: 1;
                filter: brightness(1);
            }
        }
        
        /* Particle burst effect */
        .domino-place-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #00ff9d, transparent);
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
        }
        
        @keyframes particleBurst {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--px), var(--py)) scale(0);
                opacity: 0;
            }
        }

                /* ADD after ghostPulse animation (around line 350): */
        
        /* Staggered deal animation - CONTAINED VERSION */
        .domino.deal-animation {
            animation: dealCard 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            opacity: 0;
            position: absolute !important;
            will-change: transform, opacity;
        }

        @keyframes dealCard {
            0% {
                transform: translateY(-50vh) translateX(-30px) rotate(180deg) scale(0.3);
                opacity: 0;
            }
            60% {
                transform: translateY(10px) translateX(0) rotate(-5deg) scale(1.1);
                opacity: 1;
            }
            80% {
                transform: translateY(-5px) rotate(3deg) scale(0.95);
            }
            100% {
                transform: translateY(0) rotate(0) scale(1);
                opacity: 1;
                position: relative !important;
            }
        }
        
        /* Dealing overlay for dramatic effect */
        .dealing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 20%, rgba(0, 255, 157, 0.1), transparent 50%);
            pointer-events: none;
            z-index: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
            display: none; /* Hide by default */
        }
        
        .dealing-overlay.active {
            opacity: 1;
            display: block; /* Show when active */
        }

        /* Domino tile - BASE STYLES */
        .domino {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 6px;
            display: flex;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.8);
            overflow: visible;
        }

        .domino:hover {
            transform: translateY(-3px);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.8), 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .domino.selected {
            border-color: #ffff00;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.8);
            transform: translateY(-5px);
        }

        .domino.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .domino.help-highlight {
            animation: helpPulse 1s ease-in-out 5;
            border-color: #00ff9d;
        }

        @keyframes helpPulse {
            0%, 100% {
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.8), 0 0 15px rgba(0, 255, 157, 0.8);
                border-color: #00ff9d;
            }
            50% {
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.8), 0 0 25px rgba(0, 255, 157, 1);
                border-color: #00ff9d;
            }
        }

        .domino.double-glow {
            animation: doubleGlow 1s ease-in-out infinite;
        }

        @keyframes doubleGlow {
            0%, 100% {
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.8), 0 0 15px rgba(255, 255, 0, 0.8);
                border-color: #ffff00;
            }
            50% {
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.8), 0 0 30px rgba(255, 255, 0, 1);
                border-color: #ffff00;
            }
        }

        /* HORIZONTAL dominoes for train lanes */
        .domino.horizontal {
            flex-direction: row;
            width: 70px;
            height: 50px;
            min-width: 70px;
        }
        
        /* VERTICAL dominoes for player hand */
        .domino.vertical {
            flex-direction: column;
            width: 50px;
            height: 100px;
            min-width: 50px;
        }

        .domino-half {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3em;
            font-weight: bold;
        }

        .domino.horizontal .domino-half {
            font-size: 1.3em;
        }

        /* Neon colors for each number */
        .domino-half[data-value="0"] { color: #00ffff; text-shadow: 0 0 8px #00ffff; }
        .domino-half[data-value="1"] { color: #00ff9d; text-shadow: 0 0 8px #00ff9d; }
        .domino-half[data-value="2"] { color: #ff00ff; text-shadow: 0 0 8px #ff00ff; }
        .domino-half[data-value="3"] { color: #ffff00; text-shadow: 0 0 8px #ffff00; }
        .domino-half[data-value="4"] { color: #ff6600; text-shadow: 0 0 8px #ff6600; }
        .domino-half[data-value="5"] { color: #00ccff; text-shadow: 0 0 8px #00ccff; }
        .domino-half[data-value="6"] { color: #ff0066; text-shadow: 0 0 8px #ff0066; }
        .domino-half[data-value="7"] { color: #66ff00; text-shadow: 0 0 8px #66ff00; }
        .domino-half[data-value="8"] { color: #9900ff; text-shadow: 0 0 8px #9900ff; }
        .domino-half[data-value="9"] { color: #ff3300; text-shadow: 0 0 8px #ff3300; }
        .domino-half[data-value="10"] { color: #00ff66; text-shadow: 0 0 8px #00ff66; }
        .domino-half[data-value="11"] { color: #ff9900; text-shadow: 0 0 8px #ff9900; }
        .domino-half[data-value="12"] { color: #cc00ff; text-shadow: 0 0 8px #cc00ff; }

        .domino-divider {
            background: linear-gradient(to bottom, transparent, #00ff9d, transparent);
            box-shadow: 0 0 3px #00ff9d;
        }

        .domino.horizontal .domino-divider {
            width: 1px;
            height: 100%;
            background: linear-gradient(to bottom, transparent, #00ff9d, transparent);
        }

        .domino.vertical .domino-divider {
            width: 100%;
            height: 1px;
            background: linear-gradient(to right, transparent, #00ff9d, transparent);
        }

        /* Celebration overlay */
        .celebration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            overflow: hidden;
        }

        .celebration-overlay.hidden {
            display: none;
        }

        .particle {
            position: absolute;
            font-size: 2em;
            animation: particle-fall 3s ease-out forwards;
            opacity: 0;
        }

        @keyframes particle-fall {
            0% {
                opacity: 1;
                transform: translateY(0) translateX(0) rotate(0deg) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(100vh) translateX(var(--drift)) rotate(720deg) scale(0.5);
            }
        }

        .particle.intense {
            animation: particle-fall-intense 4s ease-out forwards;
            font-size: 2.5em;
        }

        @keyframes particle-fall-intense {
            0% {
                opacity: 1;
                transform: translateY(0) translateX(0) rotate(0deg) scale(1.2);
            }
            50% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(100vh) translateX(var(--drift)) rotate(1080deg) scale(0.3);
            }
        }

        .particle.color-cycle {
            animation: particle-fall-intense 4s ease-out forwards, color-cycle 2s linear infinite;
        }

        @keyframes color-cycle {
            0% { filter: hue-rotate(0deg); }
            33% { filter: hue-rotate(120deg); }
            66% { filter: hue-rotate(240deg); }
            100% { filter: hue-rotate(360deg); }
        }

        /* Player hand area (bottom 40%) */
        .player-area {
            flex: 4;
            background: rgba(15, 15, 30, 0.9);
            border-top: 2px solid #00ffff;
            box-shadow: 0 -5px 20px rgba(0, 255, 255, 0.3);
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .player-header {
            width: 100%;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            padding-left: 290px;
        }

        .status-message-container {
            position: absolute;
            left: 300px;
            text-align: left;
            width: 250px;
        }

        .status-message-inline {
            font-size: 0.9em;
            color: #00ff9d;
            text-shadow: 0 0 5px #00ff9d;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .status-message-inline.visible {
            opacity: 1;
        }

        .hand-title-container {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .player-name {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 8px #00ffff;
            white-space: nowrap;
        }

        .btn-help {
            padding: 5px 12px;
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid rgba(255, 255, 0, 0.5);
            border-radius: 5px;
            color: #ffff00;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85em;
            flex-shrink: 0;
        }

        .btn-help:hover {
            background: rgba(255, 255, 0, 0.2);
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
        }

        .player-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            margin-left: 290px;
        }

        .btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #00ff9d 0%, #00cc7a 100%);
            border: none;
            border-radius: 5px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.5);
            font-size: 0.9em;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.8);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-light-blue {
            background: linear-gradient(135deg, #00ccff 0%, #0099cc 100%);
            box-shadow: 0 0 10px rgba(0, 204, 255, 0.5);
        }

        .btn-light-blue:hover:not(:disabled) {
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.8);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ff00ff 0%, #cc00cc 100%);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        .btn-secondary:hover:not(:disabled) {
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
        }

        .btn-draw-highlight {
            animation: drawGlow 1s ease-in-out 5;
        }

        .btn-pass-highlight {
            animation: passGlow 1s ease-in-out 5;
        }

        @keyframes drawGlow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
            }
            50% {
                box-shadow: 0 0 25px rgba(255, 255, 0, 1);
            }
        }

        @keyframes passGlow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
                border: 2px solid rgba(255, 255, 0, 0.5);
            }
            50% {
                box-shadow: 0 0 25px rgba(255, 255, 0, 1);
                border: 2px solid rgba(255, 255, 0, 1);
            }
        }

        .player-hand {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            align-items: center;
            min-height: 100px;
            max-height: calc(100% - 200px); /* Reserve space for header and buttons */
            overflow-y: auto;
            margin-bottom: 15px;
            margin-left: 290px;
            margin-top: 10px;
            padding-top: 5px;
        }
        
        /* More specific selector to ensure it overrides */
        .player-area .player-hand.dealing {
            overflow: hidden !important;
            overflow-x: hidden !important;
            overflow-y: hidden !important;
            max-height: none !important;
        }

        .player-hand::-webkit-scrollbar {
            width: 8px;
        }

        .player-hand::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .player-hand::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 157, 0.5);
            border-radius: 4px;
        }

        .player-hand::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 157, 0.7);
        }

        .player-hand .domino.vertical {
            width: 50px;
            height: 100px;
            min-width: 50px;
            flex-shrink: 1;
        }

        @media (max-height: 800px) {
            .player-hand .domino.vertical {
                width: 45px;
                height: 90px;
                min-width: 45px;
            }
            
            .player-hand {
                gap: 10px;
            }
            
            /* Also override in media query */
            .player-area .player-hand.dealing {
                overflow: hidden !important;
                overflow-x: hidden !important;
                overflow-y: hidden !important;
                max-height: none !important;
            }
        }

        .player-hand .domino {
            cursor: grab;
        }

        .player-hand .domino:active {
            cursor: grabbing;
        }

        
        /* Overlay screens */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .overlay.hidden {
            display: none;
        }

        .modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #00ff9d;
            border-radius: 15px;
            padding: 40px;
            padding-top: 60px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 0 40px rgba(0, 255, 157, 0.5);
            text-align: center;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 2em;
            color: #00ff9d;
            cursor: pointer;
            line-height: 1;
            padding: 5px 10px;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            color: #ff00ff;
            transform: scale(1.2);
            text-shadow: 0 0 10px #ff00ff;
        }

        .btn-back {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 8px 16px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            color: #00ffff;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .btn-back:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transform: translateX(-2px);
        }

        .current-game-status {
            margin: 15px 0;
            padding: 12px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            color: #00ffff;
        }

        .current-game-status strong {
            color: #00ff9d;
        }

        .status-divider {
            border: none;
            border-top: 1px solid rgba(0, 255, 157, 0.3);
            margin: 15px 0;
        }

        .modal h2 {
            font-size: 2em;
            margin-bottom: 20px;
            color: #00ff9d;
            text-shadow: 0 0 15px #00ff9d;
        }

        .modal h3 {
            font-size: 1.3em;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #00ffff;
            text-align: left;
        }

        .modal p {
            margin: 15px 0;
            font-size: 1.1em;
            color: #00ffff;
        }

        .modal ul {
            text-align: left;
            margin: 10px 0 10px 20px;
            color: #00ffff;
            line-height: 1.6;
        }

        .modal li {
            margin: 8px 0;
        }

        .difficulty-select {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 25px 0;
        }

        .difficulty-btn {
            padding: 15px 25px;
            font-size: 1.1em;
            background: rgba(0, 255, 157, 0.1);
            border: 2px solid #00ff9d;
            color: #00ff9d;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .difficulty-btn:hover {
            background: rgba(0, 255, 157, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.6);
            transform: scale(1.05);
        }

        .difficulty-btn.selected {
            background: #00ff9d;
            color: #000;
            box-shadow: 0 0 25px rgba(0, 255, 157, 0.8);
        }

        .leaderboard {
            margin: 25px 0;
            text-align: left;
        }

        .leaderboard-entry {
            padding: 10px;
            margin: 8px 0;
            background: rgba(0, 255, 157, 0.05);
            border-left: 3px solid #00ff9d;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            color: #00ffff;
        }

        .scores-table {
            width: 100%;
            margin: 20px 0;
            border-collapse: collapse;
        }

        .scores-table th,
        .scores-table td {
            padding: 10px;
            border: 1px solid rgba(0, 255, 157, 0.3);
            text-align: center;
        }

        .scores-table th {
            background: rgba(0, 255, 157, 0.2);
            color: #00ff9d;
        }

        .scores-table td {
            color: #00ffff;
        }

        .detailed-scores-table {
            width: 100%;
            margin: 20px 0;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        .detailed-scores-table th,
        .detailed-scores-table td {
            padding: 8px;
            border: 1px solid rgba(0, 255, 157, 0.3);
            text-align: center;
        }

        .detailed-scores-table th {
            background: rgba(0, 255, 157, 0.2);
            color: #00ff9d;
            font-weight: bold;
        }

        .detailed-scores-table td {
            color: #00ffff;
        }

        .detailed-scores-table .round-label {
            font-weight: bold;
            background: rgba(0, 255, 157, 0.05);
        }

        .detailed-scores-table .totals-row {
            background: rgba(0, 255, 157, 0.15);
            font-weight: bold;
            border-top: 2px solid #00ff9d;
        }

        .detailed-scores-table .current-round {
            background: rgba(255, 255, 0, 0.1);
        }

        .detailed-scores-table .winner-col {
            background: rgba(0, 255, 157, 0.2);
        }

        .detailed-scores-table .player-col {
            font-weight: bold;
        }

        /* Power-ups Panel */
        .powerups-panel {
            position: absolute;
            top: 15px;
            left: 20px;
            background: rgba(26, 26, 46, 0.95);
            border: 2px solid #00ff9d;
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 157, 0.5);
            z-index: 100;
            width: 260px;
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .powerups-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .powerup-btn {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: rgba(0, 255, 157, 0.1);
            border: 2px solid #00ff9d;
            border-radius: 10px;
            padding: 10px 8px;
            margin-bottom: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .powerup-btn:hover:not(:disabled) {
            background: rgba(0, 255, 157, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.6);
            transform: scale(1.05);
        }

        .powerup-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: #666;
        }

        .powerup-btn.used {
            background: rgba(100, 100, 100, 0.1);
            border-color: #555;
        }

        .powerup-btn.used .powerup-icon {
            filter: grayscale(100%);
            opacity: 0.5;
        }

        .powerup-btn.used .powerup-name {
            color: #666;
        }

        .powerup-btn.targeting {
            background: rgba(255, 0, 0, 0.2);
            border-color: #ff0000;
            animation: targetPulse 1s ease-in-out infinite;
        }

        .powerup-btn.targeting.freeze-mode {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
            animation: freezePulse 1s ease-in-out infinite;
        }

        @keyframes targetPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 0, 0, 0.6); }
            50% { box-shadow: 0 0 30px rgba(255, 0, 0, 1); }
        }

        @keyframes freezePulse {
            0%, 100% { box-shadow: 0 0 15px rgba(0, 255, 255, 0.6); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 255, 1); }
        }

        .powerup-icon {
            font-size: 2.7em;
            margin-bottom: 0;
        }

        .powerup-name {
            font-size: 1em;
            color: #00ffff;
            font-weight: bold;
            text-transform: none;
        }

        /* Frozen train overlay */
        .train-lane.frozen {
            position: relative;
            background: rgba(0, 255, 255, 0.1) !important;
            border-color: #00ffff !important;
        }

        .train-lane.frozen::after {
            content: '❄️ FROZEN';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 255, 0.9);
            color: #000;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 10;
            animation: frozenFloat 2s ease-in-out infinite;
        }

        @keyframes frozenFloat {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -55%) scale(1.1); }
        }

        /* Sabotage target mode */
        .train-lane.sabotage-target {
            border-color: #ff0000 !important;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8) !important;
            animation: sabotageGlow 0.5s ease-in-out infinite;
            cursor: crosshair !important;
        }

        @keyframes sabotageGlow {
            0%, 100% { background: rgba(255, 0, 0, 0.1); }
            50% { background: rgba(255, 0, 0, 0.3); }
        }

        /* Freeze target mode */
        .train-lane.freeze-target {
            border-color: #00ffff !important;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8) !important;
            animation: freezeGlow 0.5s ease-in-out infinite;
            cursor: crosshair !important;
        }

        @keyframes freezeGlow {
            0%, 100% { background: rgba(0, 255, 255, 0.1); }
            50% { background: rgba(0, 255, 255, 0.3); }
        }

        /* Power-up animations */
        @keyframes shuffleFly {
            0% {
                transform: translate(-50%, 0) rotate(0deg) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(calc(-50% + var(--endX)), var(--endY)) rotate(720deg) scale(0.3);
                opacity: 0;
            }
        }

        @keyframes explosionBurst {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--endX), var(--endY)) scale(0.3);
                opacity: 0;
            }
        }

        @keyframes tileCountFly {
            0% {
                transform: translate(0, 0) scale(2);
                opacity: 1;
            }
            100% {
                transform: translate(var(--endX), var(--endY)) scale(0.5);
                opacity: 0;
            }
        }

        @keyframes iceFall {
            0% {
                transform: translateY(-20px) scale(0);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translateY(50px) scale(1);
                opacity: 0;
            }
        }

                /* Screen shake animations */
        @keyframes shake-light {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-2px, 1px); }
            20% { transform: translate(2px, -1px); }
            30% { transform: translate(-2px, -1px); }
            40% { transform: translate(2px, 1px); }
            50% { transform: translate(-1px, 1px); }
            60% { transform: translate(1px, -1px); }
            70% { transform: translate(-1px, -1px); }
            80% { transform: translate(1px, 1px); }
            90% { transform: translate(-1px, 0); }
        }
        
        @keyframes shake-medium {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-4px, 2px); }
            20% { transform: translate(4px, -2px); }
            30% { transform: translate(-3px, -3px); }
            40% { transform: translate(3px, 3px); }
            50% { transform: translate(-2px, 1px); }
            60% { transform: translate(2px, -1px); }
            70% { transform: translate(-1px, -2px); }
            80% { transform: translate(1px, 2px); }
            90% { transform: translate(-1px, 1px); }
        }
        
        @keyframes shake-heavy {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            10% { transform: translate(-6px, 3px) rotate(-1deg); }
            20% { transform: translate(6px, -3px) rotate(1deg); }
            30% { transform: translate(-5px, -4px) rotate(-1deg); }
            40% { transform: translate(5px, 4px) rotate(1deg); }
            50% { transform: translate(-4px, 2px) rotate(-0.5deg); }
            60% { transform: translate(4px, -2px) rotate(0.5deg); }
            70% { transform: translate(-2px, -3px) rotate(-0.5deg); }
            80% { transform: translate(2px, 3px) rotate(0.5deg); }
            90% { transform: translate(-1px, 1px) rotate(0deg); }
        }

            /* ============================================
           MOBILE OPTIMIZATION - IMPROVED
           ============================================ */
        
        @media (max-width: 768px) {
            /* Header optimization */
            .game-header {
                padding: 10px 15px;
                gap: 10px;
                flex-direction: column;
            }
        
            .game-title {
                font-size: 1.2em;
                letter-spacing: 1px;
                width: 100%;
                text-align: center;
            }
        
            .game-info {
                font-size: 0.75em;
                justify-content: center;
                width: 100%;
            }
        
            .header-buttons {
                justify-content: center;
                width: 100%;
                gap: 6px;
            }
        
            .header-buttons .btn {
                padding: 6px 12px;
                font-size: 0.8em;
            }
        
            /* Train lanes optimization */
            .trains-area {
                padding: 8px;
                gap: 5px;
            }
        
            .train-lane {
                padding: 6px 8px;
                gap: 8px;
                min-height: 50px;
            }
        
            .train-info {
                min-width: 90px;
                max-width: 90px;
                padding-left: 0;
                gap: 2px;
            }
        
            .train-name {
                font-size: 0.75em;
                margin-left: 0;
                line-height: 1.2;
            }
        
            .mexican-train .train-name {
                font-size: 0.7em;
                margin-left: 0;
            }
        
            .mexican-train .train-info {
                padding-left: 0;
            }
        
            .mexican-train .turn-indicator {
                display: none;
            }
        
            .train-status {
                font-size: 0.65em;
                margin-left: 15px;
                white-space: nowrap;
                line-height: 1.1;
            }
        
            .train-info-row2 {
                font-size: 0.65em;
                gap: 6px;
                flex-wrap: nowrap;
            }
        
            .train-tile-count {
                font-size: 1em;
                white-space: nowrap;
            }
        
            .train-status-inline {
                display: none !important;
            }
        
            .engine-start {
                min-width: 30px;
                max-width: 30px;
                height: 30px;
                font-size: 0.8em;
            }
        
            .turn-indicator {
                font-size: 1.1em;
                margin-right: 3px;
            }
        
            .ai-thinking {
                font-size: 0.8em;
                min-width: 18px;
            }
        
            .ai-reaction {
                font-size: 0.95em;
                min-width: 16px;
            }
        
            .domino.horizontal {
                width: 52px;
                height: 36px;
                min-width: 52px;
            }
        
            .domino.horizontal .domino-half {
                font-size: 1.05em;
            }
        
            .domino.vertical {
                width: 46px;
                height: 92px;
                min-width: 46px;
            }
        
            /* Player area optimization */
            .player-area {
                padding: 10px;
            }
        
            .player-header {
                margin-bottom: 5px; /* Reduced from 10px */
                padding-bottom: 5px; /* Reduced from 8px */
                padding-left: 0;
                flex-direction: column;
                gap: 4px; /* Reduced from 8px */
            }
        
            .hand-title-container {
                width: 100%;
                justify-content: center;
                margin-bottom: 0; /* Remove extra space */
            }
        
            .player-name {
                font-size: 1.1em;
            }
        
            .btn-help {
                padding: 4px 10px;
                font-size: 0.8em;
            }
        
            .status-message-container {
                display: none !important;
            }
        
            .status-message-inline {
                display: none !important;
            }
        
            .player-hand {
                margin-left: 0;
                margin-top: 2px; /* Reduced from 8px */
                gap: 10px;
                padding: 8px;
                max-height: none;
                min-height: 110px;
            }
        
            .player-hand .domino.vertical {
                width: 48px;
                height: 96px;
                min-width: 48px;
            }
        
            .player-hand .domino-half {
                font-size: 1.2em;
            }
        
            .player-actions {
                margin-left: 0;
                margin-top: 10px;
                gap: 8px;
                flex-wrap: wrap;
                justify-content: center;
            }
        
            .player-actions .btn {
                flex: 1;
                min-width: 120px;
                padding: 10px 16px;
                font-size: 0.95em;
            }
        
            /* Power-ups panel - HORIZONTAL 4-COLUMN LAYOUT */
            .powerups-panel {
                position: static;
                margin: 10px auto 0;
                width: 100%;
                max-width: 100%;
                padding: 8px;
                border-radius: 8px;
            }
        
            .powerups-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 6px;
            }
        
            .powerup-btn {
                padding: 8px 4px;
                border-radius: 8px;
                aspect-ratio: 1 / 1;
            }
        
            .powerup-icon {
                font-size: 2em;
                margin-bottom: 2px;
            }
        
            .powerup-name {
                font-size: 0.7em;
                line-height: 1.1;
            }
        
            /* Modal optimization */
            .modal {
                padding: 25px 15px;
                padding-top: 50px;
                max-height: 85vh;
            }
        
            .modal h2 {
                font-size: 1.5em;
            }
        
            .modal h3 {
                font-size: 1.1em;
            }
        
            .modal p {
                font-size: 1em;
            }
        
            .difficulty-select {
                flex-direction: column;
                gap: 10px;
            }
        
            .difficulty-btn {
                width: 100%;
                padding: 12px 20px;
            }
        
            .btn-back {
                padding: 6px 12px;
                font-size: 0.85em;
            }
        
            .modal-close {
                font-size: 1.8em;
                padding: 2px 8px;
            }
        
            .scores-table,
            .detailed-scores-table {
                font-size: 0.85em;
            }
        
            .scores-table th,
            .scores-table td,
            .detailed-scores-table th,
            .detailed-scores-table td {
                padding: 6px 4px;
            }

            .train-tiles {
                overflow-x: auto;
                overflow-y: hidden;
                padding: 5px 0;
                padding-top: 10px;
                padding-bottom: 10px;
                padding-right: 60px; /* Extra space on right to show train continues */
                scroll-behavior: smooth;
                -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
                scrollbar-width: none; /* Firefox */
                -ms-overflow-style: none; /* IE/Edge */
            }
            
            /* Hide scrollbar completely */
            .train-tiles::-webkit-scrollbar {
                display: none !important;
            }
        }
        
        /* Extra small screens (phones < 480px) */
        @media (max-width: 480px) {
            .game-title {
                font-size: 1em;
            }
        
            .game-info {
                font-size: 0.7em;
            }
        
            .info-item {
                font-size: 0.95em;
            }
        
            .train-info {
                min-width: 80px;
                max-width: 80px;
            }
        
            .train-name {
                font-size: 0.7em;
            }
        
            .mexican-train .train-name {
                font-size: 0.65em;
            }
        
            .train-status {
                font-size: 0.6em;
                margin-left: 12px;
            }
        
            .train-info-row2 {
                font-size: 0.6em;
                gap: 5px;
            }
        
            .engine-start {
                min-width: 26px;
                max-width: 26px;
                height: 26px;
                font-size: 0.75em;
            }
        
            .domino.horizontal {
                width: 48px;
                height: 34px;
                min-width: 48px;
            }
        
            .domino.horizontal .domino-half {
                font-size: 0.95em;
            }
        
            .player-hand .domino.vertical {
                width: 45px;
                height: 90px;
                min-width: 45px;
            }
        
            .powerup-icon {
                font-size: 1.7em;
            }
        
            .powerup-name {
                font-size: 0.65em;
            }
        
            .player-actions .btn {
                font-size: 0.9em;
                padding: 9px 14px;
            }

            /* Ensure scrollbar stays hidden */
            .train-tiles::-webkit-scrollbar {
                display: none !important;
            }

            .train-tiles {
                scrollbar-width: none !important;
                -ms-overflow-style: none !important;
                padding-right: 50px; /* Slightly less space on very small screens */
            }

            /* Reduce spacing even more */
            .player-header {
                margin-bottom: 3px;
                padding-bottom: 3px;
                gap: 3px;
            }

            .player-hand {
                margin-top: 0;
            }
        }
        
        /* Landscape mobile optimization */
        @media (max-width: 900px) and (max-height: 500px) {
            .game-header {
                padding: 8px 12px;
            }
        
            .game-title {
                font-size: 1em;
            }
        
            .trains-area {
                padding: 5px;
                gap: 3px;
            }
        
            .train-lane {
                padding: 4px 6px;
                min-height: 40px;
            }
        
            .player-area {
                padding: 8px;
            }
        
            .player-hand {
                min-height: 80px;
                gap: 6px;
            }
        
            .player-hand .domino.vertical {
                width: 42px;
                height: 84px;
                min-width: 42px;
            }
        
            .powerups-grid {
                gap: 4px;
            }
        
            .powerup-btn {
                padding: 5px 2px;
            }
        
            .powerup-icon {
                font-size: 1.5em;
            }
        
            .powerup-name {
                font-size: 0.6em;
            }

            /* Hide scrollbar in landscape too */
            .train-tiles::-webkit-scrollbar {
                display: none !important;
            }

            .train-tiles {
                scrollbar-width: none !important;
                -ms-overflow-style: none !important;
                padding-right: 60px;
            }

            .player-header {
                margin-bottom: 2px;
                padding-bottom: 2px;
            }

            .player-hand {
                margin-top: 0;
                gap: 4px;
            }
        }    

        /* Turn indicator styles */
        .turn-indicator {
            font-size: 1.5em;
            color: #00ff9d;
            text-shadow: 0 0 20px #00ff9d;
            opacity: 0;
            transition: opacity 0.3s ease;
            margin-right: 5px;
            display: inline-block;
        }

        .train-lane.current-turn .turn-indicator {
            opacity: 1;
            animation: arrowBounce 1s ease-in-out infinite;
        }

        @keyframes arrowBounce {
            0%, 100% { 
                transform: translateX(0);
            }
            50% { 
                transform: translateX(5px);
            }
        }

        /* Name glow for current turn */
        .train-lane.current-turn .train-name {
            color: #00ff9d !important;
            text-shadow: 0 0 20px #00ff9d, 0 0 40px #00ff9d;
            animation: nameGlow 1.5s ease-in-out infinite;
        }

        @keyframes nameGlow {
            0%, 100% { 
                transform: scale(1);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.08);
                filter: brightness(1.3);
            }
        }

        /* Special styling for player's turn */

        .player-area.your-turn {
            border-top: 3px solid #00ff9d;
            box-shadow: 0 -5px 40px rgba(0, 255, 157, 0.5);
        }

        /* AI Thinking indicator */
        .ai-thinking {
            font-size: 1em;
            color: #00ff9d;
            text-shadow: 0 0 8px #00ff9d;
            letter-spacing: 0px;
            opacity: 0;
            transition: opacity 0.3s ease;
            min-width: 28px;
            display: inline-block;
            font-family: monospace;
        }

        .ai-thinking.active {
            opacity: 1;
        }

        .ai-thinking::after {
            content: '';
            animation: dotsAppear 1.2s ease-in-out infinite;
        }

        .ai-thinking.active::after {
            display: inline-block;
        }

        @keyframes dotsAppear {
            0%, 33% { content: '.'; }
            34%, 66% { content: '..'; }
            67%, 100% { content: '...'; }
        }

        /* AI Personality reaction emoji */
        .ai-reaction {
            font-size: 1.1em;
            opacity: 0;
            transition: opacity 0.2s ease;
            min-width: 22px;
            display: inline-block;
            filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.6));
        }

        .ai-reaction.active {
            opacity: 1;
            animation: reactionPop 1.5s ease-out forwards;
        }

        @keyframes reactionPop {
            0% {
                opacity: 0;
                transform: scale(0) translateY(0);
            }
            30% {
                opacity: 1;
                transform: scale(1.4) translateY(-4px);
            }
            60% {
                transform: scale(1) translateY(0);
            }
            80% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: scale(0.8) translateY(2px);
            }
        }

        /* Second line layout: Tiles in Hand + Private/Public on same row */
        .train-info-row2 {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 0.8em;
        }

        .train-tile-count {
            font-size: 1em;
            color: #888;
        }

        .train-status-inline {
            color: #888;
            white-space: nowrap;
        }

        .train-status-inline.public {
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }

        /* Boneyard pulse animation */
        @keyframes boneyardPulse {
            0% { 
                transform: scale(1);
                color: #00ff9d;
            }
            50% { 
                transform: scale(1.3);
                color: #00ff9d;
                text-shadow: 0 0 15px #00ff9d;
            }
            100% { 
                transform: scale(1);
                color: #00ff9d;
            }
        }

        /* Tile fly from boneyard animation */
        @keyframes flyFromBoneyard {
            0% {
                transform: translate(var(--startX), var(--startY)) scale(0.5) rotate(0deg);
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translate(0, 0) scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        /* Tile flip reveal animation */
        @keyframes flipReveal {
            0% {
                transform: rotateY(0deg);
                background: #1a1a2e;
            }
            50% {
                transform: rotateY(90deg);
                background: #1a1a2e;
            }
            100% {
                transform: rotateY(0deg);
                background: #0a0a0a;
            }
        }

        /* Add pulse class styling */
        .boneyard-pulse {
            animation: boneyardPulse 0.4s ease-out;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Celebration Overlay -->
        <div class="celebration-overlay hidden" id="celebration-overlay"></div>

        <!-- Header -->
        <div class="game-header">
            <div class="game-title">🚂 MEXICAN TRAIN</div>
            <div class="game-info">
                <div class="info-item">
                    <span class="info-label">Round:</span>
                    <span id="round-num">1/13</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Engine:</span>
                    <span id="engine-num">[12|12]</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Boneyard:</span>
                    <span id="boneyard-count">0</span>
                </div>
            </div>
            <div class="header-buttons">
                <button class="btn" onclick="showRules()">📋 Rules</button>
                <button class="btn btn-secondary" onclick="showDetailedScores()">📊 Scores</button>
                <button class="btn btn-light-blue" onclick="newGame()">🔄 New Game</button>
            </div>
        </div>

        <!-- Trains Area (60%) -->
        <div class="trains-area">
            <!-- Mexican Train (Public) -->
            <div class="train-lane mexican-train" id="train-mexican" data-train="mexican">
                <div class="train-info">
                    <div style="display: flex; align-items: center;">
                        <span class="turn-indicator">▶</span>
                        <div class="train-name">🚂 MEXICAN TRAIN</div>
                    </div>
                    <div class="train-status train-public">🔐 Always Playable</div>
                </div>
                <div class="engine-start" id="engine-mexican"></div>
                <div class="train-tiles" id="tiles-mexican"></div>
            </div>

            <!-- AI Player 1 Train -->
            <div class="train-lane" id="train-1" data-train="1">
                <div class="train-info">
                    <div style="display: flex; align-items: center; gap: 6px; width: 100%;">
                        <span class="turn-indicator">▶</span>
                        <div class="train-name" id="ai-name-1">👤 AI 1</div>
                        <span class="ai-thinking" id="thinking-1"></span>
                        <span class="ai-reaction" id="reaction-1"></span>
                    </div>    
                    <div class="train-info-row2">
                        <span class="train-tile-count" id="tile-count-1">Tiles: 0</span>
                        <span class="train-status-inline" id="status-1">🔒 Private</span>
                    </div>
                </div>
                <div class="engine-start" id="engine-1"></div>
                <div class="train-tiles" id="tiles-1"></div>
            </div>

            <!-- AI Player 2 Train -->
            <div class="train-lane" id="train-2" data-train="2">
                <div class="train-info">
                    <div style="display: flex; align-items: center; gap: 6px; width: 100%;">
                        <span class="turn-indicator">▶</span>
                        <div class="train-name" id="ai-name-2">👤 AI 2</div>
                        <span class="ai-thinking" id="thinking-2"></span>
                        <span class="ai-reaction" id="reaction-2"></span>
                    </div>    
                    <div class="train-info-row2">
                        <span class="train-tile-count" id="tile-count-2">Tiles: 0</span>
                        <span class="train-status-inline" id="status-2">🔒 Private</span>
                    </div>
                </div>
                <div class="engine-start" id="engine-2"></div>
                <div class="train-tiles" id="tiles-2"></div>
            </div>

            <!-- AI Player 3 Train -->
            <div class="train-lane" id="train-3" data-train="3">
                <div class="train-info">
                    <div style="display: flex; align-items: center; gap: 6px; width: 100%;">
                        <span class="turn-indicator">▶</span>
                        <div class="train-name" id="ai-name-3">👤 AI 3</div>
                        <span class="ai-thinking" id="thinking-3"></span>
                        <span class="ai-reaction" id="reaction-3"></span>
                    </div>   
                    <div class="train-info-row2">
                        <span class="train-tile-count" id="tile-count-3">Tiles: 0</span>
                        <span class="train-status-inline" id="status-3">🔒 Private</span>
                    </div>
                </div>
                <div class="engine-start" id="engine-3"></div>
                <div class="train-tiles" id="tiles-3"></div>
            </div>

            <!-- Player Train -->
            <div class="train-lane" id="train-0" data-train="0">
                <div class="train-info">
                    <div style="display: flex; align-items: center; gap: 6px; width: 100%;">
                        <span class="turn-indicator">▶</span>
                        <div class="train-name">👤 YOU</div>
                    </div>    
                    <div class="train-info-row2">
                        <span class="train-tile-count" id="tile-count-0">Tiles: 0</span>
                        <span class="train-status-inline" id="status-0">🔒 Private</span>
                    </div>
                </div>
                <div class="engine-start" id="engine-0"></div>
                <div class="train-tiles" id="tiles-0"></div>
            </div>
        </div>

        <!-- Player Hand Area (40%) -->
        <div class="player-area">
            <div class="player-header">
                <div class="hand-title-container">
                    <div class="player-name">YOUR HAND (<span id="hand-count">0</span> tiles)</div>
                    <button class="btn-help" onclick="showHelp()">💡 Help</button>
                </div>
                <div class="status-message-container">
                    <div class="status-message-inline" id="status-inline"></div>
                </div>
            </div>
            <div class="player-hand" id="player-hand"></div>
            <div class="player-actions">
                <button class="btn" id="btn-draw" onclick="drawTile()">Draw Tile</button>
                <button class="btn btn-secondary" id="btn-pass" onclick="passTurn()" disabled>Pass Turn</button>
            </div>

            <!-- Power-ups Panel -->
            <div class="powerups-panel" id="powerups-panel">
                <div class="powerups-grid">
                    <button class="powerup-btn" id="btn-wild" onclick="useWildShuffle()" disabled>
                        <span class="powerup-icon" style="position: relative; display: inline-block;">
                            🀫
                            <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.8em; color: #00ff9d; text-shadow: 0 0 8px #00ff9d;">
                                ↻
                            </span>
                        </span>
                        <span class="powerup-name">Wild Shuffle</span>
                    </button>
                    <button class="powerup-btn" id="btn-sabotage" onclick="useSabotage()" disabled>
                        <span class="powerup-icon">💣</span>
                        <span class="powerup-name">Sabotage</span>
                    </button>
                    <button class="powerup-btn" id="btn-freeze" onclick="useFreeze()" disabled>
                        <span class="powerup-icon">❄️</span>
                        <span class="powerup-name">Freeze</span>
                    </button>
                    <button class="powerup-btn" id="btn-oracle" onclick="useOracle()" disabled>
                        <span class="powerup-icon">🔮</span>
                        <span class="powerup-name">Oracle</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Dealing Animation Overlay -->
    <div class="dealing-overlay" id="dealing-overlay"></div>

    <!-- Welcome/Setup Overlay -->
    <div class="overlay" id="welcome-overlay">
        <div class="modal">
            <button id="back-to-game-btn" class="btn-back" onclick="backToCurrentGame()" style="display: none;">
                ← Back
            </button>
            
            <h2>🚂 MEXICAN TRAIN 🚂</h2>
            
            <div id="current-game-status" style="display: none;">
                <div class="current-game-status">
                    <strong>Current Game:</strong> Round <span id="status-round">X</span>/13 • Your Score: <span id="status-score">X</span> pts
                </div>
                <hr class="status-divider">
            </div>
            
            <p>Select Difficulty:</p>
            <div class="difficulty-select">
                <button class="difficulty-btn selected" data-difficulty="easy">Easy</button>
                <button class="difficulty-btn" data-difficulty="medium">Medium</button>
                <button class="difficulty-btn" data-difficulty="hard">Hard</button>
            </div>
            <button class="btn" onclick="startGame()" style="margin-top: 20px; font-size: 1.2em; padding: 12px 30px;">
                Start New Game
            </button>
        </div>
    </div>

    <!-- Rules Overlay -->
    <div class="overlay hidden" id="rules-overlay" onclick="handleOverlayClick(event, 'rules-overlay')">
        <div class="modal" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="hideRules()">×</button>
            <h2>📋 GAME RULES 📋</h2>
            
            <h3>🎯 Objective</h3>
            <p>Be the player with the <strong>lowest score</strong> after 13 rounds.</p>
            
            <h3>🎮 How to Play</h3>
            <ul>
                <li><strong>Match numbers:</strong> Place dominoes so one end matches the open end of a train, eg. 2|12 12|5 5|8</li>
                <li><strong>Your turn:</strong> Play one domino on any available train, or draw if you can't play</li>
                <li><strong>Drag & drop:</strong> Drag dominoes from your hand to highlighted trains</li>
            </ul>
            
            <h3>🚂 Train Types</h3>
            <ul>
                <li><strong>Your Train:</strong> Private (only you can play) unless you pass a turn</li>
                <li><strong>Mexican Train:</strong> Public train, always playable by everyone</li>
                <li><strong>Opponent Trains:</strong> Private, become public when they pass</li>
            </ul>
            
            <h3>🎲 Special Rules</h3>
            <ul>
                <li><strong>Doubles:</strong> Playing a double requires you to play again immediately. If you can't play after a double, you must draw a tile</li>
                <li><strong>Drawing:</strong> If you can't play, draw one tile. If still can't play, pass (your train becomes public)</li>
                <li><strong>Engine:</strong> Each round starts with a different double (12-12 down to 0-0)</li>
            </ul>
            
            <h3>⚡ Power-Ups</h3>
            <ul>
                <li><strong>Wild Shuffle (🃏):</strong> Exchange your hand for new tiles from the boneyard</li>
                <li><strong>Sabotage (💣):</strong> Force an opponent to draw 1 tile from the boneyard</li>
                <li><strong>Freeze (❄️):</strong> Make an opponent skip their next turn</li>
                <li><strong>Oracle (🔮):</strong> Preview the next tile that will be drawn from the boneyard</li>
            </ul>
            
            <h3>📊 Scoring</h3>
            <ul>
                <li>Each number shown = <strong>1 point</li>
                <li>Double-blank [0|0] = <strong>50 points</li>
                <li>Score is the sum of tiles remaining in your hand when round ends</li>
            </ul>
            
            <h3>🏆 Winning</h3>
            <p>After 13 rounds (engines 12 down to 0), the player with the <strong>lowest total score wins</strong>!</p>
            
            <button class="btn" onclick="hideRules()" style="margin-top: 20px;">
                Got it!
            </button>
        </div>
    </div>

    <!-- Detailed Scores Overlay -->
    <div class="overlay hidden" id="detailed-scores-overlay" onclick="handleOverlayClick(event, 'detailed-scores-overlay')">
        <div class="modal" style="max-width: 700px;" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="hideDetailedScores()">×</button>
            <h2>📊 DETAILED SCORECARD 📊</h2>
            <div style="overflow-x: auto;">
                <table class="detailed-scores-table" id="detailed-scores-table"></table>
            </div>
            <button class="btn" onclick="hideDetailedScores()" style="margin-top: 20px;">
                Close
            </button>
        </div>
    </div>

    <!-- Round End Overlay -->
    <div class="overlay hidden" id="round-end-overlay">
        <div class="modal">
            <h2 id="round-end-title">Round Complete!</h2>
            <table class="scores-table" id="round-scores"></table>
            <button class="btn" onclick="nextRound()" style="margin-top: 20px; font-size: 1.1em; padding: 10px 25px;">
                Next Round
            </button>
        </div>
    </div>

    <!-- Game End Overlay -->
    <div class="overlay hidden" id="game-end-overlay">
        <div class="modal">
            <h2>🏆 Game Complete! 🏆</h2>
            <table class="scores-table" id="final-scores"></table>
            <button class="btn" onclick="newGame()" style="margin-top: 20px; font-size: 1.1em; padding: 10px 25px;">
                New Game
            </button>
            <button class="btn btn-secondary" onclick="showLeaderboard()" style="margin-top: 10px; font-size: 1.1em; padding: 10px 25px;">
                View Leaderboard
            </button>
        </div>
    </div>

    <!-- Leaderboard Overlay -->
    <div class="overlay hidden" id="leaderboard-overlay">
        <div class="modal">
            <h2>📊 LEADERBOARD 📊</h2>
            <div class="leaderboard" id="leaderboard-content"></div>
            <button class="btn" onclick="hideLeaderboard()" style="margin-top: 20px;">
                Close
            </button>
        </div>
    </div>

    <script>
        // ============================================
        // DOMINO CLASS
        // ============================================
        class Domino {
            constructor(left, right) {
                this.left = left;
                this.right = right;
            }

            flip() {
                return new Domino(this.right, this.left);
            }

            total() {
                return this.left + this.right;
            }

            isDouble() {
                return this.left === this.right;
            }

            equals(other) {
                return (this.left === other.left && this.right === other.right) ||
                       (this.left === other.right && this.right === other.left);
            }

            toString() {
                return `[${this.left}|${this.right}]`;
            }

            getScore() {
                if (this.left === 0 && this.right === 0) return 50;
                return this.total();
            }
        }

        // ============================================
        // MEXICAN TRAIN GAME CLASS
        // ============================================
        class MexicanTrainGame {
            constructor(difficulty = 'medium') {
                this.difficulty = difficulty;
                this.roundEngines = [12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
                this.currentRound = 0;
                
                // Randomly select 3 AI names
                const aiNamePool = ['Jax', 'Zane', 'Meli', 'Sandra', 'Marc', 'Seb', 'Frank', 'Hector', 'Claude', 'Olivia'];
                const shuffledNames = this.shuffle([...aiNamePool]).slice(0, 3);
                this.players = ['You', ...shuffledNames];
                
                this.totalScores = [0, 0, 0, 0];
                this.roundScores = [];
                this.reset();
            }

            reset() {
                this.engine = this.roundEngines[this.currentRound];
                this.boneyard = this.createDominoSet();
                this.hands = [[], [], [], []];
                this.trains = {
                    mexican: [],
                    0: [],
                    1: [],
                    2: [],
                    3: []
                };
                this.publicTrains = new Set(['mexican']);
                this.currentPlayer = 0;
                this.roundOver = false;
                this.mustCoverDouble = null;
                this.mustPlayAfterDouble = false;
                this.hasDrawn = false;
                this.powerups = {
                    0: { wild: true, sabotage: true, freeze: true, oracle: true },
                    1: { wild: true, sabotage: true, freeze: true, oracle: true },
                    2: { wild: true, sabotage: true, freeze: true, oracle: true },
                    3: { wild: true, sabotage: true, freeze: true, oracle: true }
                };
                this.frozenPlayers = new Set();
                this.targetingMode = null;
                this.powerupUsedThisTurn = false;
                this.dealDominoes();
            }

            createDominoSet() {
                const dominoes = [];
                for (let i = 0; i <= 12; i++) {
                    for (let j = i; j <= 12; j++) {
                        dominoes.push(new Domino(i, j));
                    }
                }
                return this.shuffle(dominoes);
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            dealDominoes() {
                const tilesPerPlayer = 15;
                for (let i = 0; i < 4; i++) {
                    this.hands[i] = this.boneyard.splice(0, tilesPerPlayer);
                }
            }

            getPlayableTrains(playerIndex) {
                const playable = [];
                playable.push('mexican');
                playable.push(playerIndex);
                
                for (let train of this.publicTrains) {
                    if (train !== 'mexican' && train !== playerIndex) {
                        playable.push(train);
                    }
                }
                
                return playable;
            }

            getTrainEnd(train) {
                const trainKey = train === 'mexican' ? 'mexican' : parseInt(train);
                const tiles = this.trains[trainKey];
                
                if (tiles.length === 0) {
                    return this.engine;
                }
                
                return tiles[tiles.length - 1].right;
            }

            canPlayDomino(domino, train) {
                const end = this.getTrainEnd(train);
                return domino.left === end || domino.right === end;
            }

            playDomino(domino, train, playerIndex) {
                const trainKey = train === 'mexican' ? 'mexican' : parseInt(train);
                const end = this.getTrainEnd(train);
                
                let orientedDomino = domino;
                if (domino.left === end) {
                    orientedDomino = domino;
                } else if (domino.right === end) {
                    orientedDomino = domino.flip();
                } else {
                    console.error('Domino cannot be played on this train!');
                    return false;
                }
                
                this.trains[trainKey].push(orientedDomino);
                
                // Remove the domino from player's hand
                const handIndex = this.hands[playerIndex].findIndex(d => d.equals(domino));
                if (handIndex !== -1) {
                    this.hands[playerIndex].splice(handIndex, 1);
                }
                
                // Handle doubles
                if (orientedDomino.isDouble()) {
                    this.mustPlayAfterDouble = true;
                } else {
                    this.mustPlayAfterDouble = false;
                }
                
                // Make train private again if player played on their own public train
                if (trainKey === playerIndex && this.publicTrains.has(playerIndex)) {
                    this.publicTrains.delete(playerIndex);
                }
                
                return true;
            }

            drawFromBoneyard(playerIndex) {
                if (this.boneyard.length === 0) return null;
                const domino = this.boneyard.pop();
                this.hands[playerIndex].push(domino);
                return domino;
            }

            makeTrainPublic(playerIndex) {
                this.publicTrains.add(playerIndex);
            }

            checkRoundOver() {
                // Check if any player has emptied their hand
                for (let i = 0; i < 4; i++) {
                    if (this.hands[i].length === 0) {
                        this.roundOver = true;
                        return true;
                    }
                }
                
                // Check if boneyard is empty and no one can play
                if (this.boneyard.length === 0) {
                    let anyoneCanPlay = false;
                    for (let i = 0; i < 4; i++) {
                        const playableTrains = this.getPlayableTrains(i);
                        for (let domino of this.hands[i]) {
                            for (let train of playableTrains) {
                                if (this.canPlayDomino(domino, train)) {
                                    anyoneCanPlay = true;
                                    break;
                                }
                            }
                            if (anyoneCanPlay) break;
                        }
                        if (anyoneCanPlay) break;
                    }
                    
                    if (!anyoneCanPlay) {
                        this.roundOver = true;
                        return true;
                    }
                }
                
                return false;
            }

            getRoundScores() {
                return this.hands.map(hand => 
                    hand.reduce((sum, domino) => sum + domino.getScore(), 0)
                );
            }

            nextRound() {
                this.currentRound++;
                if (this.currentRound < this.roundEngines.length) {
                    this.reset();
                    return true;
                }
                return false;
            }
        }

        // ============================================
        // AI PLAYER CLASS
        // ============================================
        class AIPlayer {
            constructor(game, playerIndex, difficulty) {
                this.game = game;
                this.playerIndex = playerIndex;
                this.difficulty = difficulty;
            }

            chooseMove() {
                const hand = this.game.hands[this.playerIndex];
                const playableTrains = this.game.getPlayableTrains(this.playerIndex);
                
                let moves = [];
                
                for (let domino of hand) {
                    for (let train of playableTrains) {
                        if (this.game.canPlayDomino(domino, train)) {
                            const score = this.evaluateMove(domino, train);
                            moves.push({ domino, train, score });
                        }
                    }
                }
                
                if (moves.length === 0) return null;
                
                moves.sort((a, b) => b.score - a.score);
                
                if (this.difficulty === 'easy') {
                    return moves[Math.floor(Math.random() * moves.length)];
                }
                
                if (this.difficulty === 'medium') {
                    const topMoves = moves.slice(0, Math.min(3, moves.length));
                    return topMoves[Math.floor(Math.random() * topMoves.length)];
                }
                
                return moves[0];
            }

            evaluateMove(domino, train) {
                let score = 0;
                score += domino.total();
                if (domino.isDouble()) score += 20;
                if (train === this.playerIndex) score += 15;
                if (train === 'mexican') score += 10;
                if (domino.left === 0 && domino.right === 0) score += 50;
                return score;
            }
        }

        // ============================================
        // GAME STATE
        // ============================================
        let game;
        let aiPlayers = [];
        let selectedDomino = null;
        let selectedDifficulty = 'medium';
        let draggedDomino = null;
        let draggedElement = null;
        let helpTimeout = null;
        let statusMessageTimeout = null;
        let lastPlayedTrain = null;
        let targetingMode = null;

        function getLeaderboard() {
            const saved = localStorage.getItem('mexicanTrainLeaderboard');
            return saved ? JSON.parse(saved) : [];
        }

        function saveToLeaderboard(totalScore, rounds) {
            const leaderboard = getLeaderboard();
            leaderboard.push({
                date: new Date().toLocaleString(),
                score: totalScore,
                rounds: rounds,
                difficulty: selectedDifficulty
            });
            leaderboard.sort((a, b) => a.score - b.score);
            localStorage.setItem('mexicanTrainLeaderboard', JSON.stringify(leaderboard.slice(0, 10)));
        }

        function handleOverlayClick(event, overlayId) {
            if (event.target.id === overlayId) {
                document.getElementById(overlayId).classList.add('hidden');
            }
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================
        function createDominoElement(domino, options = {}) {
            const { clickable = false, selected = false, draggable = false, orientation = 'vertical' } = options;
            
            const el = document.createElement('div');
            el.className = `domino ${orientation}`;
            if (selected) el.classList.add('selected');
            
            const leftHalf = document.createElement('div');
            leftHalf.className = 'domino-half';
            leftHalf.setAttribute('data-value', domino.left);
            leftHalf.textContent = domino.left;
            
            const divider = document.createElement('div');
            divider.className = 'domino-divider';
            
            const rightHalf = document.createElement('div');
            rightHalf.className = 'domino-half';
            rightHalf.setAttribute('data-value', domino.right);
            rightHalf.textContent = domino.right;
            
            el.appendChild(leftHalf);
            el.appendChild(divider);
            el.appendChild(rightHalf);
            
            if (clickable) {
                el.style.cursor = 'pointer';
                el.addEventListener('click', () => selectDomino(domino));
            }

            if (draggable) {
                el.draggable = true;
                el.addEventListener('dragstart', (e) => {
                    draggedDomino = domino;
                    draggedElement = el;
                    el.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                el.addEventListener('dragend', () => {
                    el.classList.remove('dragging');
                    draggedDomino = null;
                    draggedElement = null;
                    document.querySelectorAll('.train-lane').forEach(lane => {
                        lane.classList.remove('drop-target');
                    });
                });
            }
            
            return el;
        }

        function updateDisplay() {
            document.getElementById('round-num').textContent = `${game.currentRound + 1}/13`;
            document.getElementById('engine-num').textContent = `[${game.engine}|${game.engine}]`;
            document.getElementById('boneyard-count').textContent = game.boneyard.length;
            
            const engineIds = ['engine-mexican', 'engine-0', 'engine-1', 'engine-2', 'engine-3'];
            engineIds.forEach(id => {
                const engineEl = document.getElementById(id);
                engineEl.textContent = game.engine;
                
                const trainKey = id.replace('engine-', '');
                const hasTiles = game.trains[trainKey] && game.trains[trainKey].length > 0;
                if (hasTiles) {
                    engineEl.classList.add('hidden');
                } else {
                    engineEl.classList.remove('hidden');
                }
            });
            
            updateTrain('mexican', game.trains.mexican);
            for (let i = 0; i < 4; i++) {
                updateTrain(i, game.trains[i]);
                updateTrainStatus(i);
            }
            
            updatePlayerHand();
            highlightPlayableTrains();
            updatePowerupButtons();
            
            // Update pass button state based on mustPlayAfterDouble
            if (game.mustPlayAfterDouble && game.currentPlayer === 0) {
                document.getElementById('btn-pass').disabled = true;
            }

            updateCurrentTurnIndicator();
        }

        function updateCurrentTurnIndicator() {
            // Remove all current-turn indicators
            document.querySelectorAll('.train-lane').forEach(lane => {
                lane.classList.remove('current-turn');
            });
            document.querySelector('.player-area').classList.remove('your-turn');
            
            // Add indicator to current player's train
            if (game.currentPlayer === 0) {
                // Player's turn
                document.querySelector('.player-area').classList.add('your-turn');
                document.getElementById('train-0').classList.add('current-turn');
            } else {
                // AI player's turn
                document.getElementById(`train-${game.currentPlayer}`).classList.add('current-turn');
            }
        }

        function updateTrain(trainKey, tiles) {
            const tilesContainer = document.getElementById(`tiles-${trainKey}`);
            if (!tilesContainer) return;
            
            tilesContainer.innerHTML = '';
            
            if (tiles && tiles.length > 0) {
                const visibleTiles = tiles.slice(-8);
                visibleTiles.forEach((domino, index) => {
                    const dominoEl = createDominoElement(domino, { orientation: 'horizontal' });
                    
                    if (index === visibleTiles.length - 1 && lastPlayedTrain === trainKey) {
                        dominoEl.classList.add('tile-slide-in');
                        if (domino.isDouble()) {
                            dominoEl.classList.add('double-glow');
                        }
                    }
                    
                    tilesContainer.appendChild(dominoEl);
                });
                
                // Auto-scroll to show last tile + empty space
                requestAnimationFrame(() => {
                    autoScrollTrainToEnd(trainKey);
                });
            }
        }

        function autoScrollTrainToEnd(trainKey) {
            const tilesContainer = document.getElementById(`tiles-${trainKey}`);
            if (!tilesContainer) return;
            
            // Scroll to show the last domino + some empty space (100px)
            const scrollTarget = tilesContainer.scrollWidth - tilesContainer.clientWidth + 100;
            tilesContainer.scrollLeft = Math.max(0, scrollTarget);
            
            // Add touch/mouse interaction to temporarily stop auto-scroll
            let userInteracting = false;
            let interactionTimeout;
            
            const handleInteractionStart = () => {
                userInteracting = true;
                tilesContainer.classList.remove('auto-scrolling');
                clearTimeout(interactionTimeout);
            };
            
            const handleInteractionEnd = () => {
                clearTimeout(interactionTimeout);
                interactionTimeout = setTimeout(() => {
                    userInteracting = false;
                    tilesContainer.classList.add('auto-scrolling');
                    // Scroll back to end after 2 seconds of no interaction
                    const scrollTarget = tilesContainer.scrollWidth - tilesContainer.clientWidth + 100;
                    tilesContainer.scrollLeft = Math.max(0, scrollTarget);
                }, 2000);
            };
            
            // Remove old listeners to prevent duplicates
            tilesContainer.removeEventListener('touchstart', handleInteractionStart);
            tilesContainer.removeEventListener('mousedown', handleInteractionStart);
            tilesContainer.removeEventListener('touchend', handleInteractionEnd);
            tilesContainer.removeEventListener('mouseup', handleInteractionEnd);
            tilesContainer.removeEventListener('scroll', handleInteractionEnd);
            
            // Add new listeners
            tilesContainer.addEventListener('touchstart', handleInteractionStart, { passive: true });
            tilesContainer.addEventListener('mousedown', handleInteractionStart);
            tilesContainer.addEventListener('touchend', handleInteractionEnd, { passive: true });
            tilesContainer.addEventListener('mouseup', handleInteractionEnd);
            tilesContainer.addEventListener('scroll', handleInteractionEnd, { passive: true });
        }

        function updateTrainStatus(trainIndex) {
            const statusEl = document.getElementById(`status-${trainIndex}`);
            if (game.publicTrains.has(trainIndex)) {
                statusEl.textContent = '🔐 Public';
                statusEl.classList.add('public');
            } else {
                statusEl.textContent = '🔒 Private';
                statusEl.classList.remove('public');
            }
        }
        
        function updatePlayerHand(animate = false) {
            const handEl = document.getElementById('player-hand');
            const hand = game.hands[0];
            
            handEl.innerHTML = '';
            document.getElementById('hand-count').textContent = hand.length;
            
            // Update tile counters for all players
            for (let i = 0; i < 4; i++) {
                const counterEl = document.getElementById(`tile-count-${i}`);
                if (counterEl) {
                    counterEl.textContent = `Dominoes: ${game.hands[i].length}`;
                }
            }
            
            const isPlayerFrozen = game.frozenPlayers.has(0);
            const canInteract = game.currentPlayer === 0 && !game.roundOver && !isPlayerFrozen;

            if (animate) {
                // Add dealing class to prevent scrollbars
                document.body.classList.add('dealing');
                document.querySelector('.game-container').classList.add('dealing');
                document.querySelector('.player-area').classList.add('dealing');
                handEl.classList.add('dealing');

                // Staggered dealing animation
                hand.forEach((domino, index) => {
                    setTimeout(() => {
                        const isSelected = selectedDomino && domino.equals(selectedDomino);
                        const el = createDominoElement(domino, {
                            clickable: canInteract,
                            selected: isSelected,
                            draggable: canInteract,
                            orientation: 'vertical'
                        });
                        
                        el.classList.add('deal-animation');
                        el.style.animationDelay = `${index * 0.06}s`;
                        
                        handEl.appendChild(el);
                        
                        // Remove animation class after it completes
                        setTimeout(() => {
                            el.classList.remove('deal-animation');
                        }, 500 + (index * 60));
                    }, index * 60);
                });

                // Remove dealing classes after animation completes
                const totalDuration = hand.length * 60 + 600;
                setTimeout(() => {
                    document.body.classList.remove('dealing');
                    document.querySelector('.game-container').classList.remove('dealing');
                    document.querySelector('.player-area').classList.remove('dealing');
                    handEl.classList.remove('dealing');
                }, totalDuration);
            } else {
                // Instant display (no animation)
                hand.forEach(domino => {
                    const isSelected = selectedDomino && domino.equals(selectedDomino);
                    const el = createDominoElement(domino, {
                        clickable: canInteract,
                        selected: isSelected,
                        draggable: canInteract,
                        orientation: 'vertical'
                    });
                    handEl.appendChild(el);
                });
            }
        }

        function highlightPlayableTrains() {
            document.querySelectorAll('.train-lane').forEach(lane => {
                lane.classList.remove('playable');
                lane.style.cursor = 'default';
                lane.onclick = null;
                
                lane.ondragover = null;
                lane.ondragenter = null;
                lane.ondragleave = null;
                lane.ondrop = null;
            });
            
            const isPlayerFrozen = game.frozenPlayers.has(0);
            if (game.currentPlayer !== 0 || game.roundOver || isPlayerFrozen) return;
            
            const playableTrains = game.getPlayableTrains(0);
            playableTrains.forEach(train => {
                const trainEl = document.getElementById(`train-${train}`);
                if (trainEl) {
                    trainEl.classList.add('playable');
                    
                    trainEl.ondragover = (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                    };
                    
                    trainEl.ondragenter = (e) => {
                        e.preventDefault();
                        if (draggedDomino && game.canPlayDomino(draggedDomino, train)) {
                            trainEl.classList.add('drop-target');
                        }
                    };
                    
                    trainEl.ondragleave = () => {
                        trainEl.classList.remove('drop-target');
                    };
                    
                    trainEl.ondrop = (e) => {
                        e.preventDefault();
                        trainEl.classList.remove('drop-target');
                        if (draggedDomino && game.canPlayDomino(draggedDomino, train)) {
                            playDomino(draggedDomino, train);
                        }
                    };
                }
            });
        }

        function showDetailedScores() {
            const overlay = document.getElementById('detailed-scores-overlay');
            if (!overlay) return;
            
            if (!game) {
                // Show empty scorecard if no game
                const table = document.getElementById('detailed-scores-table');
                table.innerHTML = '<tr><th colspan="5" style="text-align: center; padding: 20px; color: #888;">No game in progress</th></tr>';
                overlay.classList.remove('hidden');
                return;
            }
            
            // ...existing code for displaying scores
            const table = document.getElementById('detailed-scores-table');
            let html = '<tr><th>Round [Engine]</th><th>You</th><th>Jax</th><th>Kira</th><th>Zane</th></tr>';
            
            for (let i = 0; i < game.roundScores.length; i++) {
                const scores = game.roundScores[i];
                const engine = game.roundEngines[i];
                const isCurrent = i === game.currentRound;
                html += `<tr class="${isCurrent ? 'current-round' : ''}">
                    <td class="round-label">R${i + 1} [${engine}]</td>
                    <td class="player-col">${scores[0]}</td>
                    <td>${scores[1]}</td>
                    <td>${scores[2]}</td>
                    <td>${scores[3]}</td>
                </tr>`;
            }
            
            for (let i = game.roundScores.length; i < 13; i++) {
                const engine = game.roundEngines[i];
                const isCurrent = i === game.currentRound;
                html += `<tr class="${isCurrent ? 'current-round' : ''}">
                    <td class="round-label">R${i + 1} [${engine}]</td>
                    <td class="player-col">-</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                </tr>`;
            }
            
            const minScore = Math.min(...game.totalScores);
            html += `<tr class="totals-row">
                <td><strong>TOTAL</strong></td>
                <td class="${game.totalScores[0] === minScore ? 'winner-col' : ''} player-col"><strong>${game.totalScores[0]}</strong></td>
                <td class="${game.totalScores[1] === minScore ? 'winner-col' : ''}"><strong>${game.totalScores[1]}</strong></td>
                <td class="${game.totalScores[2] === minScore ? 'winner-col' : ''}"><strong>${game.totalScores[2]}</strong></td>
                <td class="${game.totalScores[3] === minScore ? 'winner-col' : ''}"><strong>${game.totalScores[3]}</strong></td>
            </tr>`;
            
            table.innerHTML = html;
            overlay.classList.remove('hidden');
        }

        function hideDetailedScores() {
            document.getElementById('detailed-scores-overlay').classList.add('hidden');
        }

        function showHelp() {
            const isPlayerFrozen = game.frozenPlayers.has(0);
            if (game.currentPlayer !== 0 || game.roundOver || isPlayerFrozen) return;
            
            clearHelpHighlights();
            
            const hand = game.hands[0];
            const playableTrains = game.getPlayableTrains(0);
            const playableEnds = playableTrains.map(train => game.getTrainEnd(train));
            
            let hasPlayableTiles = false;
            const handElements = document.querySelectorAll('.player-hand .domino');
            
            handElements.forEach((el, index) => {
                const domino = hand[index];
                const isPlayable = playableEnds.some(end => 
                    domino.left === end || domino.right === end
                );
                
                if (isPlayable) {
                    el.classList.add('help-highlight');
                    hasPlayableTiles = true;
                }
            });
            
            if (hasPlayableTiles) {
                showMessage('✅ These tiles can be played on highlighted trains!');
            } else if (game.mustPlayAfterDouble) {
                showMessage('❌ Must play after double. Draw a tile!');
                document.getElementById('btn-draw').classList.add('btn-draw-highlight');
            } else if (game.hasDrawn && !document.getElementById('btn-pass').disabled) {
                showMessage('❌ No playable tiles. Pass your turn.');
                document.getElementById('btn-pass').classList.add('btn-pass-highlight');
            } else {
                showMessage('❌ No playable dominoes this turn. Draw a tile!');
                document.getElementById('btn-draw').classList.add('btn-draw-highlight');
            }
            
            helpTimeout = setTimeout(clearHelpHighlights, 5000);
        }

        function clearHelpHighlights() {
            if (helpTimeout) {
                clearTimeout(helpTimeout);
                helpTimeout = null;
            }
            document.querySelectorAll('.help-highlight').forEach(el => {
                el.classList.remove('help-highlight');
            });
            document.getElementById('btn-draw').classList.remove('btn-draw-highlight');
            document.getElementById('btn-pass').classList.remove('btn-pass-highlight');
        }

        function selectDomino(domino) {
            const isPlayerFrozen = game.frozenPlayers.has(0);
            if (game.currentPlayer !== 0 || game.roundOver || isPlayerFrozen) return;
            
            clearHelpHighlights();
            selectedDomino = domino;
            updateDisplay();
            
            const playableTrains = game.getPlayableTrains(0);
            let canPlayAnywhere = false;
            
            for (let train of playableTrains) {
                if (game.canPlayDomino(domino, train)) {
                    canPlayAnywhere = true;
                    break;
                }
            }
            
            if (canPlayAnywhere) {
                showMessage(`Selected ${domino} - Click a highlighted train to play`);
                enableTrainClick();
            } else {
                showMessage(`Selected ${domino} - Cannot play this tile!`);
            }
        }

        function enableTrainClick() {
            const playableTrains = game.getPlayableTrains(0);
            
            playableTrains.forEach(train => {
                const trainEl = document.getElementById(`train-${train}`);
                if (trainEl && selectedDomino && game.canPlayDomino(selectedDomino, train)) {
                    trainEl.style.cursor = 'pointer';
                    trainEl.onclick = () => playDomino(selectedDomino, train);
                }
            });
        }

        function playDomino(domino, train) {
            if (!domino || game.currentPlayer !== 0) return;
            
            clearHelpHighlights();
            
            if (game.playDomino(domino, train, 0)) {
                // Create particle burst effect
                createPlacementParticles(train);
                
                const trainNames = {
                    'mexican': 'Mexican Train',
                    0: 'your train',
                    1: 'Jax\'s train',
                    2: 'Kira\'s train',
                    3: 'Zane\'s train'
                };
                const trainName = trainNames[train] || `train ${train}`;
                
                if (domino.isDouble()) {
                    showMessage(`Played ${domino} on ${trainName} - DOUBLE! Play again`);
                } else {
                    showMessage(`Played ${domino} on ${trainName}`);
                }
                
                selectedDomino = null;
                game.hasDrawn = false;
                
                document.querySelectorAll('.train-lane').forEach(lane => {
                    lane.style.cursor = 'default';
                    lane.onclick = null;
                });
                

                lastPlayedTrain = train;
                updateDisplay();

                setTimeout(() => {
                    lastPlayedTrain = null;
                }, 100);

                setTimeout(() => {
                    const dominoEls = document.querySelectorAll('.domino.double-glow, .domino.tile-slide-in');
                    dominoEls.forEach(el => {
                        el.classList.remove('double-glow');
                        el.classList.remove('tile-slide-in');
                    });
                }, 1500);
                
                if (game.mustPlayAfterDouble) {
                    // Player must play again after double
                    document.getElementById('btn-pass').disabled = true;
                    return;
                }
                
                if (game.checkRoundOver()) {
                    endRound();
                } else {
                    nextPlayer();
                }
            }
        }

        function drawTile() {
            const isPlayerFrozen = game.frozenPlayers.has(0);
            if (game.currentPlayer !== 0 || game.roundOver || game.hasDrawn || isPlayerFrozen) return;
            
            clearHelpHighlights();
            
            const domino = game.drawFromBoneyard(0);
            if (domino) {
                game.hasDrawn = true;
                
                // Instantly update boneyard count and pulse it
                document.getElementById('boneyard-count').textContent = game.boneyard.length;
                const boneyardCountEl = document.getElementById('boneyard-count');
                boneyardCountEl.classList.add('boneyard-pulse');
                setTimeout(() => boneyardCountEl.classList.remove('boneyard-pulse'), 400);
                
                showMessage(`Drew ${domino}`);
                
                // Add dealing class to prevent scrollbars
                const handEl = document.getElementById('player-hand');
                document.documentElement.classList.add('dealing');
                document.body.classList.add('dealing');
                document.querySelector('.game-container').classList.add('dealing');
                document.querySelector('.player-area').classList.add('dealing');
                handEl.classList.add('dealing');

                const hand = game.hands[0];
                const canInteract = game.currentPlayer === 0 && !game.roundOver && !isPlayerFrozen;

                handEl.innerHTML = '';
                document.getElementById('hand-count').textContent = hand.length;

                hand.forEach((d, index) => {
                    const isSelected = selectedDomino && d.equals(selectedDomino);
                    const el = createDominoElement(d, {
                        clickable: canInteract,
                        selected: isSelected,
                        draggable: canInteract,
                        orientation: 'vertical'
                    });
                    
                    handEl.appendChild(el);
                    
                    // Only animate the last tile (newly drawn)
                    if (index === hand.length - 1) {
                        // Get boneyard position
                        const boneyardEl = document.getElementById('boneyard-count').parentElement;
                        const boneyardRect = boneyardEl.getBoundingClientRect();
                        const rect = el.getBoundingClientRect();
                        
                        const startX = boneyardRect.left + boneyardRect.width / 2 - rect.left - rect.width / 2;
                        const startY = boneyardRect.top + boneyardRect.height / 2 - rect.top - rect.height / 2;
                        
                        // Start face-down at boneyard
                        el.style.position = 'absolute';
                        el.style.left = `${rect.left}px`;
                        el.style.top = `${rect.top}px`;
                        el.style.transform = `translate(${startX}px, ${startY}px) scale(0.5) rotateY(0deg)`;
                        el.style.opacity = '0';
                        el.style.background = '#1a1a2e';
                        el.style.transition = 'none';
                        el.querySelectorAll('.domino-half').forEach(half => half.style.opacity = '0');
                        
                        // Fly to position
                        setTimeout(() => {
                            el.style.transition = 'all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)';
                            el.style.transform = 'translate(0, 0) scale(1) rotateY(0deg)';
                            el.style.opacity = '1';
                        }, 50);
                        
                        // Flip reveal after arrival
                        setTimeout(() => {
                            el.style.position = 'relative';
                            el.style.left = '0';
                            el.style.top = '0';
                            el.style.animation = 'flipReveal 0.5s ease-out';
                            
                            setTimeout(() => {
                                el.querySelectorAll('.domino-half').forEach(half => {
                                    half.style.transition = 'opacity 0.2s ease';
                                    half.style.opacity = '1';
                                });
                                el.style.background = '#0a0a0a';
                                
                                // Add green glow
                                setTimeout(() => {
                                    el.style.border = '2px solid #00ff9d';
                                    el.style.boxShadow = '0 0 15px rgba(0, 255, 157, 0.8)';
                                    
                                    setTimeout(() => {
                                        el.style.transition = 'all 0.3s ease';
                                        el.style.border = '1px solid #333';
                                        el.style.boxShadow = 'inset 0 1px 3px rgba(0, 0, 0, 0.8)';
                                    }, 800);
                                }, 250);
                            }, 250);
                        }, 650);
                    }
                });

                setTimeout(() => {
                    document.documentElement.classList.remove('dealing');
                    document.body.classList.remove('dealing');
                    document.querySelector('.game-container').classList.remove('dealing');
                    document.querySelector('.player-area').classList.remove('dealing');
                    handEl.classList.remove('dealing');
                }, 1700);

                for (let i = 0; i < 4; i++) {
                    const counterEl = document.getElementById(`tile-count-${i}`);
                    if (counterEl) {
                        counterEl.textContent = `Dominoes: ${game.hands[i].length}`;
                    }
                }
                
                highlightPlayableTrains();
                updatePowerupButtons();
                
                const playableTrains = game.getPlayableTrains(0);
                let canPlayDrawnTile = false;
                for (let train of playableTrains) {
                    if (game.canPlayDomino(domino, train)) {
                        canPlayDrawnTile = true;
                        break;
                    }
                }
                
                if (!canPlayDrawnTile && !game.mustPlayAfterDouble) {
                    document.getElementById('btn-pass').disabled = false;
                } else if (!canPlayDrawnTile && game.mustPlayAfterDouble) {
                    game.mustPlayAfterDouble = false;
                    document.getElementById('btn-pass').disabled = false;
                }
            } else {
                showMessage('Boneyard is empty!');
                if (!game.mustPlayAfterDouble) {
                    document.getElementById('btn-pass').disabled = false;
                } else {
                    game.mustPlayAfterDouble = false;
                    document.getElementById('btn-pass').disabled = false;
                }
            }
        }

        function passTurn() {
            if (game.currentPlayer !== 0 || !game.hasDrawn) return;
            
            clearHelpHighlights();
            game.makeTrainPublic(0);
            game.mustPlayAfterDouble = false;
            showMessage('Passed turn - Your train is now public');
            game.hasDrawn = false;
            document.getElementById('btn-pass').disabled = true;
            updateDisplay();
            
            if (game.checkRoundOver()) {
                endRound();
            } else {
                nextPlayer();
            }
        }

        function nextPlayer() {
            game.powerupUsedThisTurn = false;
            game.currentPlayer = (game.currentPlayer + 1) % 4;
            document.getElementById('btn-pass').disabled = true;
            clearTargetingMode();

            updateCurrentTurnIndicator();
            
            // Check if next player is frozen - thaw them
            if (game.frozenPlayers.has(game.currentPlayer)) {
                thawPlayer(game.currentPlayer);
                
                if (game.currentPlayer === 0) {
                    // Player is frozen, show message and skip
                    showMessage('⚠️ You skip this turn because you are frozen');
                    setTimeout(() => {
                        nextPlayer();
                    }, 2000);
                    return;
                } else {
                    // AI player is frozen, skip
                    showMessage(`${game.players[game.currentPlayer]}\'s turn skipped (frozen)`);
                    setTimeout(() => {
                        nextPlayer();
                    }, 1000);
                    return;
                }
            }
            
            updateDisplay();
            
            if (game.currentPlayer !== 0) {
                setTimeout(aiTurn, 800);
            }
        }

        function endRound() {
            const scores = game.getRoundScores();
            game.roundScores.push(scores);
            
            for (let i = 0; i < 4; i++) {
                game.totalScores[i] += scores[i];
            }
            
            const minScore = Math.min(...scores);
            const playerHasLowestScore = scores[0] === minScore;
            const playerEmptiedHand = game.hands[0].length === 0;
            
            // Show celebration for player wins
            if (playerHasLowestScore || playerEmptiedHand) {
                screenShake('heavy');
                setTimeout(() => createCelebration(false), 300);
            }
            
            // Create table with count-up animation
            let tableHTML = `
                <tr>
                    <th>Player</th>
                    <th>Round Score</th>
                    <th>Total Score</th>
                </tr>`;
            
            game.players.forEach((player, i) => {
                const isLowest = scores[i] === minScore;
                tableHTML += `
                <tr style="${isLowest ? 'background: rgba(0,255,157,0.1);' : ''}">
                    <td>${player}${isLowest ? ' 🏆' : ''}</td>
                    <td><span class="score-counter" data-target="${scores[i]}">0</span></td>
                    <td><span class="score-counter" data-target="${game.totalScores[i]}">0</span></td>
                </tr>`;
            });
            
            document.getElementById('round-scores').innerHTML = tableHTML;
            
            // Animate score count-up
            setTimeout(() => {
                document.querySelectorAll('.score-counter').forEach((el, index) => {
                    const target = parseInt(el.getAttribute('data-target'));
                    const duration = 1000;
                    const steps = 30;
                    const increment = target / steps;
                    const delay = duration / steps;
                    
                    let current = 0;
                    const timer = setInterval(() => {
                        current += increment;
                        if (current >= target) {
                            el.textContent = target;
                            clearInterval(timer);
                        } else {
                            el.textContent = Math.floor(current);
                        }
                    }, delay);
                });
            }, 300);
            
            if (game.currentRound === game.roundEngines.length - 1) {
                setTimeout(endGame, 2500);
            } else {
                document.getElementById('round-end-title').textContent = 
                    `Round ${game.currentRound + 1} Complete!`;
                document.getElementById('round-end-overlay').classList.remove('hidden');
            }
        }

        function nextRound() {
            document.getElementById('round-end-overlay').classList.add('hidden');

            // Clear all power-up effects for new round
            clearAllPowerupEffects();

            game.currentPlayer = 0;
            game.hasDrawn = false;
            game.mustPlayAfterDouble = false;
            selectedDomino = null;
            document.getElementById('btn-pass').disabled = true;
            game.nextRound();
            
            updateDisplay();

            // Trigger staggered dealing for new round
            setTimeout(() => {
                animateDealingSequence();
            }, 300);
            
            if (game.currentPlayer !== 0) {
                setTimeout(aiTurn, 1000);
            }
        }

        function endGame() {
            const winner = game.totalScores.indexOf(Math.min(...game.totalScores));
            
            // Intense celebration if player wins
            if (winner === 0) {
                screenShake('heavy');
                setTimeout(() => createCelebration(true), 500);
            }
            
            let tableHTML = `
                <tr>
                    <th>Player</th>
                    <th>Final Score</th>
                </tr>`;
            
            game.players.forEach((player, i) => {
                tableHTML += `
                <tr style="${i === winner ? 'background: rgba(0,255,157,0.2); font-weight: bold;' : ''}">
                    <td>${player} ${i === winner ? '🏆' : ''}</td>
                    <td><span class="score-counter" data-target="${game.totalScores[i]}">0</span></td>
                </tr>`;
            });
            
            document.getElementById('final-scores').innerHTML = tableHTML;
            document.getElementById('game-end-overlay').classList.remove('hidden');
            
            // Animate final scores
            setTimeout(() => {
                document.querySelectorAll('.score-counter').forEach(el => {
                    const target = parseInt(el.getAttribute('data-target'));
                    const duration = 1500;
                    const steps = 40;
                    const increment = target / steps;
                    const delay = duration / steps;
                    
                    let current = 0;
                    const timer = setInterval(() => {
                        current += increment;
                        if (current >= target) {
                            el.textContent = target;
                            clearInterval(timer);
                        } else {
                            el.textContent = Math.floor(current);
                        }
                    }, delay);
                });
            }, 300);
            
            if (winner === 0) {
                saveToLeaderboard(game.totalScores[0], 13);
            }
        }

        function createCelebration(isGameWin = false) {
            const overlay = document.getElementById('celebration-overlay');
            overlay.classList.remove('hidden');
            overlay.innerHTML = '';
            
            const particleCount = isGameWin ? 50 : 30;
            const emojis = ['🎉', '✨', '🎊', '⭐', '💫', '🌟'];
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = isGameWin ? 'particle intense color-cycle' : 'particle';
                particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.top = `${Math.random() * 20}%`;
                
                const drift = (Math.random() - 0.5) * 400;
                particle.style.setProperty('--drift', `${drift}px`);
                
                particle.style.animationDelay = `${Math.random() * 0.5}s`;
                
                overlay.appendChild(particle);
            }
            
            setTimeout(() => {
                overlay.classList.add('hidden');
            }, isGameWin ? 4500 : 3500);
        }

        function showMessage(text, persist = false) {
            const statusEl = document.getElementById('status-inline');
            
            if (statusMessageTimeout) {
                clearTimeout(statusMessageTimeout);
            }
            
            statusEl.textContent = text;
            statusEl.classList.add('visible');
            
            if (!persist) {
                statusMessageTimeout = setTimeout(() => {
                    statusEl.classList.remove('visible');
                }, 3000);
            }
        }

        function showRules() {
            const overlay = document.getElementById('rules-overlay');
            if (overlay) {
                overlay.classList.remove('hidden');
            }
        }

        function hideRules() {
            document.getElementById('rules-overlay').classList.add('hidden');
        }

        function showLeaderboard() {
            const leaderboard = getLeaderboard();
            const content = document.getElementById('leaderboard-content');
            
            if (leaderboard.length === 0) {
                content.innerHTML = '<p style="text-align: center; color: #888;">No games played yet!</p>';
            } else {
                content.innerHTML = leaderboard.map((entry, i) => `
                    <div class="leaderboard-entry">
                        <strong>#${i + 1}</strong> - ${entry.date}
                        <br><small style="color: #888;">${entry.difficulty.toUpperCase()} difficulty</small>
                        <div style="text-align: right;">
                            <strong>${entry.score}</strong> points
                            <br><small style="color: #888;">${entry.rounds} rounds</small>
                        </div>
                    </div>
                `).join('');
            }
            
            document.getElementById('leaderboard-overlay').classList.remove('hidden');
        }

        function hideLeaderboard() {
            document.getElementById('leaderboard-overlay').classList.add('hidden');
        }

        function backToCurrentGame() {
            document.getElementById('welcome-overlay').classList.add('hidden');
        }

        function startGame() {
            document.getElementById('back-to-game-btn').style.display = 'none';
            document.getElementById('current-game-status').style.display = 'none';
            
            // Clear all power-up effects from previous game
            clearAllPowerupEffects();

            document.getElementById('welcome-overlay').classList.add('hidden');
            game = new MexicanTrainGame(selectedDifficulty);
            aiPlayers = [
                new AIPlayer(game, 1, selectedDifficulty),
                new AIPlayer(game, 2, selectedDifficulty),
                new AIPlayer(game, 3, selectedDifficulty)
            ];
            
            // UPDATE AI NAMES IN UI - ADD THIS
            updateAINames();
            
            updateDisplay();
            
            // Then trigger staggered dealing animation
            setTimeout(() => {
                animateDealingSequence();
            }, 300);

            if (game.currentPlayer !== 0) {
                setTimeout(aiTurn, 1000);
            }
        }

        function newGame() {
            // Clear all power-up effects from previous game
            clearAllPowerupEffects();
            
            // If there's a game in progress, show back button and status
            if (game && game.currentRound < game.roundEngines.length - 1) {
                document.getElementById('back-to-game-btn').style.display = 'block';
                document.getElementById('current-game-status').style.display = 'block';
                document.getElementById('status-round').textContent = game.currentRound + 1;
                document.getElementById('status-score').textContent = game.totalScores[0];
            } else {
                document.getElementById('back-to-game-btn').style.display = 'none';
                document.getElementById('current-game-status').style.display = 'none';
            }
            
            // Show the welcome overlay
            document.getElementById('welcome-overlay').classList.remove('hidden');
            
            // Close any other overlays that might be open
            document.getElementById('game-end-overlay').classList.add('hidden');
            document.getElementById('leaderboard-overlay').classList.add('hidden');
            document.getElementById('round-end-overlay').classList.add('hidden');
            document.getElementById('rules-overlay').classList.add('hidden');
            document.getElementById('detailed-scores-overlay').classList.add('hidden');
        }

        function showAiThinking(playerIndex) {
            const el = document.getElementById(`thinking-${playerIndex}`);
            if (el) el.classList.add('active');
        }

        function hideAiThinking(playerIndex) {
            const el = document.getElementById(`thinking-${playerIndex}`);
            if (el) el.classList.remove('active');
        }

        function showAiReaction(playerIndex, emoji) {
            const el = document.getElementById(`reaction-${playerIndex}`);
            if (!el) return;
            el.textContent = emoji;
            el.classList.remove('active');
            // Force reflow to restart animation
            void el.offsetWidth;
            el.classList.add('active');
            // Clean up after animation finishes
            setTimeout(() => {
                el.classList.remove('active');
                el.textContent = '';
            }, 1500);
        }

        function aiTurn() {
            try {
                const ai = aiPlayers[game.currentPlayer - 1];
                if (!ai) {
                    console.error('AI player not found');
                    nextPlayer();
                    return;
                }
                showAiThinking(game.currentPlayer);

                if (!game.powerupUsedThisTurn && Math.random() < 0.3) {
                    const usedPowerup = aiUsePowerup(game.currentPlayer, ai.difficulty);
                    if (usedPowerup) {
                        game.powerupUsedThisTurn = true;
                        setTimeout(() => {
                            hideAiThinking(game.currentPlayer);
                            aiMakeMove(ai);
                        }, 1500);
                        return;
                    }
                }
                
                setTimeout(() => {
                    hideAiThinking(game.currentPlayer);
                    aiMakeMove(ai);
                }, 600);
            } catch (error) {
                console.error('Error in AI turn:', error);
                nextPlayer();
            }
        }

        function aiMakeMove(ai) {
            const move = ai.chooseMove();
            
            if (move) {
                const wasDouble = move.domino.isDouble();
                game.playDomino(move.domino, move.train, game.currentPlayer);
                createPlacementParticles(move.train);
                showMessage(`${game.players[game.currentPlayer]} played ${move.domino}`);
                
                if (wasDouble) showAiReaction(game.currentPlayer, '😈');

                lastPlayedTrain = move.train;
                updateDisplay();

                setTimeout(() => {
                    lastPlayedTrain = null;
                }, 100);

                setTimeout(() => {
                    const dominoEls = document.querySelectorAll('.domino.double-glow, .domino.tile-slide-in');
                    dominoEls.forEach(el => {
                        el.classList.remove('double-glow');
                        el.classList.remove('tile-slide-in');
                    });
                }, 1500);
                
                if (wasDouble && game.mustPlayAfterDouble) {
                    setTimeout(() => {
                        aiMakeMove(ai);
                    }, 800);
                    return;
                }
                
                if (game.checkRoundOver()) {
                    setTimeout(endRound, 1000);
                } else {
                    setTimeout(nextPlayer, 1000);
                }
            } else {
                const drawn = game.drawFromBoneyard(game.currentPlayer);
                if (drawn) {
                    aiDrawTileWithAnimation(game.currentPlayer); // Use new animation
                    showMessage(`${game.players[game.currentPlayer]} drew a tile`);
                    updateDisplay();
                    
                    const aiRetry = aiPlayers[game.currentPlayer - 1];
                    const retryMove = aiRetry.chooseMove();
                    
                    if (retryMove) {
                        setTimeout(() => {
                            const wasDouble = retryMove.domino.isDouble();
                            game.playDomino(retryMove.domino, retryMove.train, game.currentPlayer);
                            showMessage(`${game.players[game.currentPlayer]} played ${retryMove.domino}`);
                            
                            lastPlayedTrain = retryMove.train;
                            updateDisplay();

                            setTimeout(() => {
                                lastPlayedTrain = null;
                            }, 100);

                            setTimeout(() => {
                                const dominoEls = document.querySelectorAll('.domino.double-glow, .domino.tile-slide-in');
                                dominoEls.forEach(el => {
                                    el.classList.remove('double-glow');
                                    el.classList.remove('tile-slide-in');
                                });
                            }, 1500);
                            
                            if (wasDouble && game.mustPlayAfterDouble) {
                                setTimeout(() => {
                                    aiMakeMove(aiRetry);
                                }, 800);
                                return;
                            }
                            
                            if (game.checkRoundOver()) {
                                setTimeout(endRound, 1000);
                            } else {
            setTimeout(() => boneyardCountEl.classList.remove('boneyard-pulse'), 400);
            
            // Update tile counter
            const counterEl = document.getElementById(`tile-count-${aiIndex}`);
            if (counterEl) {
                counterEl.textContent = `Dominoes: ${game.hands[aiIndex].length}`;
            }
        }

        // ============================================
        // POWER-UP FUNCTIONS
        // ============================================
        
        function useWildShuffle() {
            if (!game.powerups[0].wild || game.powerupUsedThisTurn || game.currentPlayer !== 0) return;
            
            // Clear any targeting mode when using wild shuffle
            clearTargetingMode();
            
            const handSize = game.hands[0].length;
            const handEl = document.getElementById('player-hand');
            
            // Fade out current hand
            handEl.style.transition = 'opacity 0.4s ease-out';
            handEl.style.opacity = '0';
            
            showMessage('🃏 Wild Shuffle used! Dealing new hand...');
            
            setTimeout(() => {
                // Exchange tiles while hand is invisible
                game.boneyard.push(...game.hands[0]);
                game.boneyard = game.shuffle(game.boneyard);
                game.hands[0] = game.boneyard.splice(0, handSize);
                
                game.powerups[0].wild = false;
                game.powerupUsedThisTurn = true;
                updatePowerupButtons();
                
                // Clear the hand element completely to prevent flicker
                handEl.innerHTML = '';
                
                // Reset opacity and clear transition
                handEl.style.opacity = '1';
                handEl.style.transition = '';
                
                // Small delay before animation starts
                setTimeout(() => {
                    animateDealingSequence();
                }, 50);
            }, 400);
        }

        function createShuffleAnimation() {
            const container = document.body;
            for (let i = 0; i < 20; i++) {
                const card = document.createElement('div');
                card.style.position = 'fixed';
                card.style.left = '50%';
                card.style.bottom = '40%';
                card.style.fontSize = '2em';
                card.textContent = '🃏';
                card.style.pointerEvents = 'none';
                card.style.zIndex = '1000';
                
                const angle = (Math.PI * 2 * i) / 20;
                const distance = 200 + Math.random() * 100;
                const endX = Math.cos(angle) * distance;
                const endY = Math.sin(angle) * distance;
                
                card.style.animation = `shuffleFly 1s ease-out forwards`;
                card.style.setProperty('--endX', `${endX}px`);
                card.style.setProperty('--endY', `${endY}px`);
                card.style.animationDelay = `${i * 0.05}s`;
                
                container.appendChild(card);
                setTimeout(() => card.remove(), 1200);
            }
        }

        function useSabotage() {
            if (!game.powerups[0].sabotage || game.powerupUsedThisTurn || game.currentPlayer !== 0) return;
            
            // Clear any previous targeting mode first
            clearTargetingMode();
            
            targetingMode = 'sabotage';
            game.targetingMode = 'sabotage';
            
            highlightTargetableTrains('sabotage');
            document.getElementById('btn-sabotage').classList.add('targeting');
            showMessage('💣 Select opponent train to sabotage (ESC to cancel)', true);
            document.body.classList.add('targeting-cursor');
        }

        function applySabotage(targetPlayer) {
            if (targetPlayer === 0) return;
            if (game.frozenPlayers.has(targetPlayer)) {
                showMessage('Cannot sabotage frozen player!');
                clearTargetingMode();
                return;
            }
            
            const drawnTile = game.drawFromBoneyard(targetPlayer);
            
            if (drawnTile) {
                screenShake('medium');
                showMessage(`💣 ${game.players[targetPlayer]} was sabotaged! Drew 1 tile`);
                createExplosionAnimation(targetPlayer);
                createTileCountAnimation(targetPlayer);
                if (targetPlayer !== 0) showAiReaction(targetPlayer, '😤');
            } else {
                showMessage(`💣 Sabotage failed - boneyard empty`);
            }
            
            game.powerups[0].sabotage = false;
            game.powerupUsedThisTurn = true;
            
            clearTargetingMode();
            updatePowerupButtons();
            updateDisplay();
        }

        function createExplosionAnimation(targetPlayer) {
            const trainEl = document.getElementById(`train-${targetPlayer}`);
            const rect = trainEl.getBoundingClientRect();
            const explosionX = rect.left + 100; // Left side of train lane
            const explosionY = rect.top + rect.height / 2;
            
            for (let i = 0; i < 15; i++) {
                const particle = document.createElement('div');
                particle.textContent = '💥';
                particle.style.position = 'fixed';
                particle.style.left = `${explosionX}px`;
                particle.style.top = `${explosionY}px`;
                particle.style.fontSize = '2em';
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '1000';
                
                const angle = (Math.PI * 2 * i) / 15;
                const distance = 100 + Math.random() * 50;
                const endX = Math.cos(angle) * distance;
                const endY = Math.sin(angle) * distance;
                
                particle.style.setProperty('--endX', `${endX}px`);
                particle.style.setProperty('--endY', `${endY}px`);
                particle.style.animation = 'explosionBurst 0.8s ease-out forwards';
                
                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 900);
            }
            
            trainEl.style.background = 'rgba(255, 0, 0, 0.5)';
            setTimeout(() => {
                trainEl.style.background = '';
            }, 200);
        }

        function createTileCountAnimation(trainIndex) {
            const trainEl = document.getElementById(`train-${trainIndex}`);
            const counterEl = document.getElementById(`tile-count-${trainIndex}`);
            
            if (!trainEl || !counterEl) return;
            
            const startRect = trainEl.getBoundingClientRect();
            const explosionX = startRect.left + 100; // Match explosion position
            const explosionY = startRect.top + startRect.height / 2;
            const endRect = counterEl.getBoundingClientRect();
            
            const plusOne = document.createElement('div');
            plusOne.textContent = '+1';
            plusOne.style.position = 'fixed';
            plusOne.style.left = `${explosionX}px`;
            plusOne.style.top = `${explosionY}px`;
            plusOne.style.fontSize = '2em';
            plusOne.style.fontWeight = 'bold';
            plusOne.style.color = '#ff0000';
            plusOne.style.textShadow = '0 0 10px #ff0000';
            plusOne.style.pointerEvents = 'none';
            plusOne.style.zIndex = '1001';
            
            const endX = endRect.right - explosionX - 10; // Target right side of counter
            const endY = endRect.top - explosionY + endRect.height / 2;
            
            plusOne.style.setProperty('--endX', `${endX}px`);
            plusOne.style.setProperty('--endY', `${endY}px`);
            plusOne.style.animation = 'tileCountFly 1s ease-out forwards';
            
            document.body.appendChild(plusOne);
            
            setTimeout(() => {
                plusOne.remove();
                // Only highlight the number part, not the whole text
                const currentText = counterEl.textContent;
                const numberMatch = currentText.match(/\d+/);
                if (numberMatch) {
                    const number = numberMatch[0];
                    counterEl.innerHTML = currentText.replace(number, `<span style="color: #ff0000; transform: scale(1.3); display: inline-block;">${number}</span>`);
                    setTimeout(() => {
                        counterEl.textContent = currentText; // Restore original
                    }, 440);
                }
            }, 1000);
        }

        function useFreeze() {
            if (!game.powerups[0].freeze || game.powerupUsedThisTurn || game.currentPlayer !== 0) return;
            
            // Clear any previous targeting mode first
            clearTargetingMode();
            
            targetingMode = 'freeze';
            game.targetingMode = 'freeze';
            
            highlightTargetableTrains('freeze');
            document.getElementById('btn-freeze').classList.add('targeting', 'freeze-mode');
            showMessage('❄️ Select opponent train to freeze (ESC to cancel)', true);
            document.body.classList.add('targeting-cursor');
        }

        function applyFreeze(targetPlayer) {
            if (targetPlayer === 0) return;
            if (game.frozenPlayers.has(targetPlayer)) {
                showMessage('Player is already frozen!');
                clearTargetingMode();
                return;
            }
            
            game.frozenPlayers.add(targetPlayer);
            screenShake('light');
            showMessage(`❄️ ${game.players[targetPlayer]} is frozen! Skipping next turn`);
            createIceAnimation(targetPlayer);
            if (targetPlayer !== 0) showAiReaction(targetPlayer, '😶');
            
            game.powerups[0].freeze = false;
            game.powerupUsedThisTurn = true;
            
            clearTargetingMode();
            updatePowerupButtons();
            updateDisplay();
        }

        function createIceAnimation(targetPlayer) {
            const trainEl = document.getElementById(`train-${targetPlayer}`);
            trainEl.classList.add('frozen');
            
            const rect = trainEl.getBoundingClientRect();
            for (let i = 0; i < 20; i++) {
                const ice = document.createElement('div');
                ice.textContent = '❄️';
                ice.style.position = 'fixed';
                ice.style.left = `${rect.left + Math.random() * rect.width}px`;
                ice.style.top = `${rect.top + Math.random() * rect.height}px`;
                ice.style.fontSize = '1.5em';
                ice.style.pointerEvents = 'none';
                ice.style.zIndex = '999';
                ice.style.animation = 'iceFall 2s ease-out forwards';
                ice.style.animationDelay = `${i * 0.05}s`;
                
                document.body.appendChild(ice);
                setTimeout(() => ice.remove(), 2200);
            }
        }

        function thawPlayer(playerIndex) {
            game.frozenPlayers.delete(playerIndex);
            const trainEl = document.getElementById(`train-${playerIndex}`);
            if (trainEl) {
                trainEl.classList.remove('frozen');
            }
        }

        function highlightTargetableTrains(mode) {
            const opponents = [1, 2, 3];
            
            opponents.forEach(index => {
                const trainEl = document.getElementById(`train-${index}`);
                
                if (game.frozenPlayers.has(index) && mode === 'freeze') {
                    trainEl.style.cursor = 'not-allowed';
                    return;
                }
                
                if (mode === 'sabotage') {
                    trainEl.classList.add('sabotage-target');
                    trainEl.onclick = () => applySabotage(index);
                } else if (mode === 'freeze') {
                    trainEl.classList.add('freeze-target');
                    trainEl.onclick = () => applyFreeze(index);
                }
            });
        }

        function clearTargetingMode() {
            targetingMode = null;
            if (game) game.targetingMode = null;
            
            document.querySelectorAll('.train-lane').forEach(lane => {
                lane.classList.remove('sabotage-target', 'freeze-target');
                lane.style.cursor = '';
                const trainIndex = lane.getAttribute('data-train');
                if (trainIndex !== 'mexican' && trainIndex !== '0') {
                    lane.onclick = null;
                }
            });
            
            document.getElementById('btn-sabotage').classList.remove('targeting');
            document.getElementById('btn-freeze').classList.remove('targeting', 'freeze-mode');
            document.body.classList.remove('targeting-cursor');
        }

        function updatePowerupButtons() {
            const isPlayerFrozen = game.frozenPlayers.has(0);
            const isPlayerTurn = game.currentPlayer === 0 && !game.roundOver && !isPlayerFrozen;
            const canUsePowerup = isPlayerTurn && !game.powerupUsedThisTurn;
            
            const wildBtn = document.getElementById('btn-wild');
            wildBtn.disabled = !canUsePowerup || !game.powerups[0].wild;
            wildBtn.classList.toggle('used', !game.powerups[0].wild);
            
            const sabotageBtn = document.getElementById('btn-sabotage');
            sabotageBtn.disabled = !canUsePowerup || !game.powerups[0].sabotage;
            sabotageBtn.classList.toggle('used', !game.powerups[0].sabotage);
            
            const freezeBtn = document.getElementById('btn-freeze');
            freezeBtn.disabled = !canUsePowerup || !game.powerups[0].freeze;
            freezeBtn.classList.toggle('used', !game.powerups[0].freeze);
            
            const oracleBtn = document.getElementById('btn-oracle');
            oracleBtn.disabled = !canUsePowerup || !game.powerups[0].oracle;
            oracleBtn.classList.toggle('used', !game.powerups[0].oracle);
            
            // Update button states if player is frozen
            if (isPlayerFrozen) {
                document.getElementById('btn-draw').disabled = true;
                document.getElementById('btn-pass').disabled = true;
            } else if (game.currentPlayer === 0 && !game.roundOver) {
                document.getElementById('btn-draw').disabled = false;
            }
        }

        function useOracle() {
            if (!game.powerups[0].oracle || game.powerupUsedThisTurn || game.currentPlayer !== 0) return;
            
            // Clear any targeting mode when using oracle
            clearTargetingMode();
            
            if (game.boneyard.length === 0) {
                showMessage('🔮 Oracle: Boneyard is empty!');
                return;
            }
            
            const nextTile = game.boneyard[game.boneyard.length - 1];
            
            game.powerups[0].oracle = false;
            game.powerupUsedThisTurn = true;
            
            createOracleVisionAnimation(nextTile);
            
            updatePowerupButtons();
        }

        function createOracleVisionAnimation(domino) {
            const boneyardEl = document.getElementById('boneyard-count').parentElement;
            const boneyardRect = boneyardEl.getBoundingClientRect();
            
            const visionOverlay = document.createElement('div');
            visionOverlay.style.position = 'fixed';
            visionOverlay.style.top = '0';
            visionOverlay.style.left = '0';
            visionOverlay.style.width = '100%';
            visionOverlay.style.height = '100%';
            visionOverlay.style.background = 'rgba(0, 0, 0, 0.8)';
            visionOverlay.style.zIndex = '1500';
            visionOverlay.style.display = 'flex';
            visionOverlay.style.alignItems = 'center';
            visionOverlay.style.justifyContent = 'center';
            visionOverlay.style.opacity = '0';
            visionOverlay.style.transition = 'opacity 0.3s ease';
            
            const dominoPreview = createDominoElement(domino, { orientation: 'vertical' });
            dominoPreview.style.transform = 'scale(3)';
            dominoPreview.style.boxShadow = '0 0 50px rgba(138, 43, 226, 1), 0 0 100px rgba(138, 43, 226, 0.8)';
            dominoPreview.style.border = '3px solid #8a2be2';
            dominoPreview.style.position = 'relative';
            dominoPreview.style.zIndex = '1501';
            
            const oracleText = document.createElement('div');
            oracleText.textContent = '🔮 ORACLE VISION 🔮';
            oracleText.style.position = 'absolute';
            oracleText.style.top = '20%';
            oracleText.style.left = '50%';
            oracleText.style.transform = 'translateX(-50%)';
            oracleText.style.fontSize = '2em';
            oracleText.style.color = '#8a2be2';
            oracleText.style.textShadow = '0 0 20px #8a2be2';
            oracleText.style.fontWeight = 'bold';
            oracleText.style.zIndex = '1502';
            
            visionOverlay.appendChild(oracleText);
            visionOverlay.appendChild(dominoPreview);
            document.body.appendChild(visionOverlay);
            
            setTimeout(() => {
                visionOverlay.style.opacity = '1';
            }, 10);
            
            showMessage(`🔮 Next tile in boneyard: ${domino}`);
            
            setTimeout(() => {
                const startX = window.innerWidth / 2;
                const startY = window.innerHeight / 2;
                const endX = boneyardRect.left + boneyardRect.width / 2;
                const endY = boneyardRect.top + boneyardRect.height / 2;
                
                const flyingTile = dominoPreview.cloneNode(true);
                flyingTile.style.position = 'fixed';
                flyingTile.style.left = `${startX}px`;
                flyingTile.style.top = `${startY}px`;
                flyingTile.style.transform = 'translate(-50%, -50%) scale(3)';
                flyingTile.style.boxShadow = '0 0 50px rgba(138, 43, 226, 1), 0 0 100px rgba(138, 43, 226, 0.8)';
                flyingTile.style.border = '3px solid #8a2be2';
                flyingTile.style.transition = 'all 1s cubic-bezier(0.4, 0.0, 0.2, 1)';
                flyingTile.style.zIndex = '1503';
                
                document.body.appendChild(flyingTile);
                
                visionOverlay.style.opacity = '0';
                
                setTimeout(() => {
                    flyingTile.style.left = `${endX}px`;
                    flyingTile.style.top = `${endY}px`;
                    flyingTile.style.transform = 'translate(-50%, -50%) scale(0.3)';
                    flyingTile.style.opacity = '0';
                }, 50);
                
                setTimeout(() => {
                    visionOverlay.remove();
                    flyingTile.remove();
                }, 1100);
                
            }, 2000);
        }

        function aiUsePowerup(aiIndex, difficulty) {
            const powerups = game.powerups[aiIndex];
            const availablePowerups = [];
            
            if (powerups.wild) availablePowerups.push('wild');
            if (powerups.sabotage) availablePowerups.push('sabotage');
            if (powerups.freeze) availablePowerups.push('freeze');
            if (powerups.oracle) availablePowerups.push('oracle');
            
            if (availablePowerups.length === 0) return false;
            
            const chosenPowerup = availablePowerups[Math.floor(Math.random() * availablePowerups.length)];
            
            if (chosenPowerup === 'wild') {
                const handSize = game.hands[aiIndex].length;
                game.boneyard.push(...game.hands[aiIndex]);
                game.boneyard = game.shuffle(game.boneyard);
                game.hands[aiIndex] = game.boneyard.splice(0, handSize);
                game.powerups[aiIndex].wild = false;
                showMessage(`${game.players[aiIndex]} used Wild Shuffle 🃏`);
                updateDisplay();
                return true;
            }
            
            if (chosenPowerup === 'oracle') {
                if (game.boneyard.length > 0) {
                    game.powerups[aiIndex].oracle = false;
                    showMessage(`${game.players[aiIndex]} used Oracle 🔮`);
                    updateDisplay();
                    return true;
                }
                return false;
            }
            
            if (chosenPowerup === 'sabotage' || chosenPowerup === 'freeze') {
                let targetPlayer;
                const playerChance = difficulty === 'easy' ? 0.1 : difficulty === 'medium' ? 0.2 : 0.4;
                
                if (Math.random() < playerChance) {
                    targetPlayer = 0;
                } else {
                    const opponents = [0, 1, 2, 3].filter(i => i !== aiIndex && !game.frozenPlayers.has(i));
                    if (opponents.length === 0) return false;
                    targetPlayer = opponents.reduce((weakest, current) => 
                        game.hands[current].length < game.hands[weakest].length ? current : weakest
                    );
                }
                
                if (game.frozenPlayers.has(targetPlayer) && chosenPowerup === 'freeze') return false;
                
                if (chosenPowerup === 'sabotage') {
                    const drawnTile = game.drawFromBoneyard(targetPlayer);
                    if (drawnTile) {
                        game.powerups[aiIndex].sabotage = false;
                        showMessage(`${game.players[aiIndex]} sabotaged ${game.players[targetPlayer]}! 💣`);
                        createExplosionAnimation(targetPlayer);
                        if (targetPlayer !== 0) {
                            createTileCountAnimation(targetPlayer);
                            showAiReaction(targetPlayer, '😤');
                        } else {
                            createPlayerSabotageAnimation(drawnTile);
                        }
                        updateDisplay();
                        return true;
                    }
                } else if (chosenPowerup === 'freeze') {
                    game.frozenPlayers.add(targetPlayer);
                    game.powerups[aiIndex].freeze = false;
                    showMessage(`${game.players[aiIndex]} froze ${game.players[targetPlayer]}! ❄️`);
                    createIceAnimation(targetPlayer);
                    if (targetPlayer !== 0) showAiReaction(targetPlayer, '😶');
                    updateDisplay();
                    return true;
                }
            }
            
            return false;
        }

        // Power-up hover tooltips
        function setupPowerupTooltips() {
            const tooltips = {
                'btn-wild': 'Return your hand to the boneyard and shuffle. Redraw a new hand.',
                'btn-sabotage': 'Force an opponent to draw 1 tile.',
                'btn-freeze': 'Freeze an opponent for their next turn.',
                'btn-oracle': 'View the next tile in the boneyard.'
            };
            
            Object.entries(tooltips).forEach(([btnId, message]) => {
                const btn = document.getElementById(btnId);
                btn.addEventListener('mouseenter', () => {
                    if (!btn.disabled) {
                        showMessage(message, true);
                    }
                });
                btn.addEventListener('mouseleave', () => {
                    const statusEl = document.getElementById('status-inline');
                    statusEl.classList.remove('visible');
                });
            });
        }

        function createPlayerSabotageAnimation(drawnTile) {
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'rgba(0, 0, 0, 0.7)';
            overlay.style.zIndex = '1500';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.opacity = '0';
            overlay.style.transition = 'opacity 0.3s ease';
            
            const dominoEl = createDominoElement(drawnTile, { orientation: 'vertical' });
            dominoEl.style.transform = 'scale(3)';
            dominoEl.style.boxShadow = '0 0 50px rgba(255, 0, 0, 1), 0 0 100px rgba(255, 0, 0, 0.8)';
            dominoEl.style.border = '3px solid #ff0000';
            dominoEl.style.zIndex = '1501';

            const sabotageText = document.createElement('div');
            sabotageText.textContent = 'YOU HAVE BEEN SABOTAGED! +1 DOMINO';
            sabotageText.style.position = 'absolute';
            sabotageText.style.top = '20%';
            sabotageText.style.left = '50%';
            sabotageText.style.transform = 'translateX(-50%)';
            sabotageText.style.fontSize = '2em';
            sabotageText.style.color = '#ff0000';
            sabotageText.style.textShadow = '0 0 20px #ff0000';
            sabotageText.style.fontWeight = 'bold';
            sabotageText.style.zIndex = '1502';
    
    overlay.appendChild(sabotageText);
            
            overlay.appendChild(dominoEl);
            document.body.appendChild(overlay);
            
            setTimeout(() => overlay.style.opacity = '1', 10);
            
            setTimeout(() => {
                const handEl = document.getElementById('player-hand');
                const handRect = handEl.getBoundingClientRect();
                const startX = window.innerWidth / 2;
                const startY = window.innerHeight / 2;
                const endX = handRect.left + handRect.width / 2;
                const endY = handRect.top + handRect.height / 2;
                
                dominoEl.style.transition = 'all 1s ease-out';
                dominoEl.style.transform = `translate(${endX - startX}px, ${endY - startY}px) scale(0.5)`;
                dominoEl.style.opacity = '0';
                overlay.style.opacity = '0';
                
                setTimeout(() => {
                    overlay.remove();
                    updateDisplay();
                }, 1000);
            }, 3000);
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedDifficulty = btn.getAttribute('data-difficulty');
                });
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && targetingMode) {
                    clearTargetingMode();
                    showMessage('Power-up cancelled');
                }
            });
            
            setupPowerupTooltips();
        });

        function createPlacementParticles(trainKey) {
            const trainEl = document.getElementById(`train-${trainKey}`);
            if (!trainEl) return;
            
            const tilesContainer = trainEl.querySelector('.train-tiles');
            if (!tilesContainer) return;
            
            const rect = tilesContainer.getBoundingClientRect();
            const centerX = rect.right - 35; // Near the last tile
            const centerY = rect.top + rect.height / 2;
            
            // Create 12 particles in a burst
            for (let i = 0; i < 12; i++) {
                const particle = document.createElement('div');
                particle.className = 'domino-place-particle';
                particle.style.position = 'fixed';
                particle.style.left = `${centerX}px`;
                particle.style.top = `${centerY}px`;
                
                const angle = (Math.PI * 2 * i) / 12;
                const distance = 30 + Math.random() * 20;
                const px = Math.cos(angle) * distance;
                const py = Math.sin(angle) * distance;
                
                particle.style.setProperty('--px', `${px}px`);
                particle.style.setProperty('--py', `${py}px`);
                particle.style.animation = `particleBurst 0.6s ease-out forwards`;
                particle.style.animationDelay = `${Math.random() * 0.1}s`;
                
                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 700);
            }
        }

        function screenShake(intensity = 'medium') {
            const container = document.querySelector('.game-container');
            const shakes = {
                light: 'shake-light 0.3s ease-out',
                medium: 'shake-medium 0.4s ease-out',
                heavy: 'shake-heavy 0.5s ease-out'
            };
            container.style.animation = shakes[intensity];
            setTimeout(() => {
                container.style.animation = '';
            }, 500);
        }

        function clearAllPowerupEffects() {
            // Clear targeting mode
            clearTargetingMode();
            
            // Remove all frozen states
            document.querySelectorAll('.train-lane.frozen').forEach(lane => {
                lane.classList.remove('frozen');
            });
            
            // Remove any lingering ice particles
            document.querySelectorAll('[style*="iceFall"]').forEach(ice => {
                ice.remove();
            });
            
            // Remove any explosion particles
            document.querySelectorAll('[style*="explosionBurst"]').forEach(particle => {
                particle.remove();
            });
            
            // Remove any other power-up visual effects
            document.querySelectorAll('.sabotage-target, .freeze-target').forEach(el => {
                el.classList.remove('sabotage-target', 'freeze-target');
            });

            // Clear turn indicators
            document.querySelectorAll('.train-lane').forEach(lane => {
                lane.classList.remove('current-turn');
            });
            document.querySelector('.player-area')?.classList.remove('your-turn');

            // Clear all AI thinking + reaction indicators
            [1, 2, 3].forEach(i => {
                hideAiThinking(i);
                const r = document.getElementById(`reaction-${i}`);
                if (r) { r.classList.remove('active'); r.textContent = ''; }
            });
        }

        function animateDealingSequence() {
            const overlay = document.getElementById('dealing-overlay');
            const handEl = document.getElementById('player-hand');
            const playerArea = document.querySelector('.player-area');
            const gameContainer = document.querySelector('.game-container');
            
            // Lock scroll position BEFORE adding classes
            const scrollY = window.scrollY;
            document.documentElement.style.overflow = 'hidden';
            document.body.style.overflow = 'hidden';
            document.body.style.position = 'fixed';
            document.body.style.top = `-${scrollY}px`;
            document.body.style.width = '100vw';
            
            // Add dealing classes
            overlay.classList.add('active');
            document.documentElement.classList.add('dealing');
            document.body.classList.add('dealing');
            gameContainer.classList.add('dealing');
            playerArea.classList.add('dealing');
            handEl.classList.add('dealing');
            
            showMessage('🎴 Dealing dominoes...', true);
            
            // Trigger animated hand update
            setTimeout(() => {
                updatePlayerHand(true);
            }, 100);
            
            // Remove overlay and restore scroll after dealing
            const totalDuration = 100 + (game.hands[0].length * 60) + 600;
            setTimeout(() => {
                overlay.classList.remove('active');
                
                // Remove all dealing classes
                document.documentElement.classList.remove('dealing');
                document.body.classList.remove('dealing');
                gameContainer.classList.remove('dealing');
                playerArea.classList.remove('dealing');
                handEl.classList.remove('dealing');
                
                // Restore scroll position
                document.documentElement.style.overflow = '';
                document.body.style.overflow = '';
                document.body.style.position = '';
                document.body.style.top = '';
                document.body.style.width = '';
                window.scrollTo(0, scrollY);
                
                showMessage(''); // Clear message
            }, totalDuration);
        }

        function updateAINames() {
            for (let i = 1; i <= 3; i++) {
                const nameEl = document.getElementById(`ai-name-${i}`);
                if (nameEl && game && game.players[i]) {
                    nameEl.textContent = `👤 ${game.players[i].toUpperCase()}`;
                }
            }
        }
    </script>
</body> 
</html>
