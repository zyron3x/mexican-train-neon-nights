<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a5f2a 0%, #0d3d16 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .status {
            background: rgba(0,0,0,0.3);
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
        }

        .game-area {
            width: 100%;
            max-width: 1000px;
        }

        .hand-container {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .hand-label {
            color: #aaffaa;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hand {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            min-height: 70px;
        }

        .domino {
            display: flex;
            background: linear-gradient(145deg, #ffffff, #e6e6e6);
            border-radius: 8px;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
            cursor: default;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .domino.clickable {
            cursor: pointer;
        }

        .domino.clickable:hover {
            transform: translateY(-5px);
            box-shadow: 4px 4px 12px rgba(0,0,0,0.4);
        }

        .domino.selected {
            transform: translateY(-8px);
            box-shadow: 0 0 20px #ffcc00, 4px 4px 12px rgba(0,0,0,0.4);
            outline: 3px solid #ffcc00;
        }

        .domino.double {
            background: linear-gradient(145deg, #ffffcc, #e6e6aa);
        }

        .domino.hidden {
            background: linear-gradient(145deg, #4444aa, #333388);
        }

        .domino-half {
            width: 35px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .domino.hidden .domino-half {
            color: #fff;
            font-size: 20px;
        }

        .domino-divider {
            width: 2px;
            background: #999;
            margin: 5px 0;
        }

        .domino.hidden .domino-divider {
            background: #6666cc;
        }

        .board-container {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            min-height: 120px;
        }

        .board-info {
            color: #aaffaa;
            font-size: 14px;
            margin-bottom: 15px;
            text-align: center;
        }

        .board {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            justify-content: center;
            align-items: center;
            min-height: 70px;
        }

        .board .domino {
            transform: scale(0.9);
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-play {
            background: linear-gradient(145deg, #4CAF50, #388E3C);
            color: white;
        }

        .btn-play:hover:not(:disabled) {
            background: linear-gradient(145deg, #5CBF60, #48A04C);
            transform: translateY(-2px);
        }

        .btn-draw {
            background: linear-gradient(145deg, #2196F3, #1976D2);
            color: white;
        }

        .btn-draw:hover:not(:disabled) {
            background: linear-gradient(145deg, #42A5F5, #2196F3);
            transform: translateY(-2px);
        }

        .btn-new {
            background: linear-gradient(145deg, #FF9800, #F57C00);
            color: white;
        }

        .btn-new:hover {
            background: linear-gradient(145deg, #FFA726, #FF9800);
            transform: translateY(-2px);
        }

        .info {
            color: #aaa;
            font-size: 14px;
            text-align: center;
        }

        .winner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .winner-modal {
            background: linear-gradient(145deg, #2a7f3a, #1a5f2a);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            color: white;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }

        .winner-modal h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }

        .winner-modal p {
            font-size: 18px;
            margin-bottom: 10px;
            opacity: 0.9;
        }

        .winner-modal button {
            margin-top: 20px;
        }

        .hidden-overlay {
            display: none;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ² Domino Game</h1>

    <div class="status" id="status">Your turn - Select a domino</div>

    <div class="game-area">
        <div class="hand-container">
            <div class="hand-label">AI's Hand</div>
            <div class="hand" id="ai-hand"></div>
        </div>

        <div class="board-container">
            <div class="board-info" id="board-info">Board is empty - Play first domino</div>
            <div class="board" id="board"></div>
        </div>

        <div class="controls">
            <button class="btn-play" id="btn-left" disabled onclick="playSelected('left')">Play Left</button>
            <button class="btn-play" id="btn-right" disabled onclick="playSelected('right')">Play Right</button>
            <button class="btn-draw" id="btn-draw" onclick="drawTile()">Draw Tile</button>
            <button class="btn-new" onclick="newGame()">New Game</button>
        </div>

        <div class="hand-container">
            <div class="hand-label">Your Hand</div>
            <div class="hand" id="player-hand"></div>
        </div> 

        <div class="info" id="boneyard-info">Boneyard: 14 tiles remaining</div>
    </div>

    <div class="winner-overlay hidden-overlay" id="winner-overlay">
        <div class="winner-modal">
            <h2 id="winner-title">Game Over!</h2>
            <p id="winner-scores"></p>
            <button class="btn-new" onclick="newGame()">Play Again</button>
        </div>
    </div>

    <script>
        // ============================================
        // DOMINO CLASS - Represents a single domino tile
        // ============================================
        class Domino {
            constructor(left, right) {
                this.left = left;   // Left side value (0-6)
                this.right = right; // Right side value (0-6)
            }

            // Returns a new domino with sides swapped
            flip() {
                return new Domino(this.right, this.left);
            }

            // Returns sum of both sides
            total() {
                return this.left + this.right;
            }

            // Checks if both sides have same value
            isDouble() {
                return this.left === this.right;
            }

            // Compares two dominoes (order-independent)
            equals(other) {
                return (this.left === other.left && this.right === other.right) ||
                       (this.left === other.right && this.right === other.left);
            }

            // String representation for display
            toString() {
                return `[${this.left}|${this.right}]`;
            }
        }

        // ============================================
        // DOMINO GAME CLASS - Core game logic
        // ============================================
        class DominoGame {
            constructor() {
                this.reset();
            }

            reset() {
                // Create standard double-six domino set (28 tiles)
                this.boneyard = [];
                for (let i = 0; i <= 6; i++) {
                    for (let j = i; j <= 6; j++) {
                        this.boneyard.push(new Domino(i, j));
                    }
                }
                this.shuffle(this.boneyard);

                // Deal 7 tiles to each player
                this.playerHand = this.boneyard.splice(0, 7);
                this.aiHand = this.boneyard.splice(0, 7);

                // Initialize board state
                this.board = [];        // Played dominoes in order
                this.leftEnd = null;    // Value at left end of board
                this.rightEnd = null;   // Value at right end of board

                // Determine starting player
                this.playerTurn = this.determineFirstPlayer();
                this.gameOver = false;
                this.winner = null;
            }

            // Fisher-Yates shuffle algorithm
            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            // Player with highest double goes first (or random if tie)
            determineFirstPlayer() {
                const playerDoubles = this.playerHand.filter(d => d.isDouble());
                const aiDoubles = this.aiHand.filter(d => d.isDouble());

                const playerHighest = playerDoubles.length > 0
                    ? Math.max(...playerDoubles.map(d => d.total()))
                    : -1;
                const aiHighest = aiDoubles.length > 0
                    ? Math.max(...aiDoubles.map(d => d.total()))
                    : -1;

                if (playerHighest > aiHighest) return true;
                if (aiHighest > playerHighest) return false;
                return Math.random() < 0.5;
            }

            // Returns array of valid placements: ['left'], ['right'], or ['left', 'right']
            canPlay(domino) {
                // First move can be played anywhere
                if (this.board.length === 0) return ['left'];

                const placements = [];
                // Check if domino matches left end
                if (domino.left === this.leftEnd || domino.right === this.leftEnd) {
                    placements.push('left');
                }
                // Check if domino matches right end
                if (domino.left === this.rightEnd || domino.right === this.rightEnd) {
                    placements.push('right');
                }
                return placements;
            }

            // Plays a domino on specified side, returns true if successful
            playDomino(domino, side) {
                if (!this.canPlay(domino).includes(side)) return false;

                if (this.board.length === 0) {
                    // First domino on board
                    this.board.push(domino);
                    this.leftEnd = domino.left;
                    this.rightEnd = domino.right;
                } else if (side === 'left') {
                    // Add to left side (flip if needed to match)
                    if (domino.right === this.leftEnd) {
                        this.board.unshift(domino);
                        this.leftEnd = domino.left;
                    } else {
                        this.board.unshift(domino.flip());
                        this.leftEnd = domino.right;
                    }
                } else {
                    // Add to right side (flip if needed to match)
                    if (domino.left === this.rightEnd) {
                        this.board.push(domino);
                        this.rightEnd = domino.right;
                    } else {
                        this.board.push(domino.flip());
                        this.rightEnd = domino.left;
                    }
                }
                return true;
            }

            // Draws one tile from boneyard, returns null if empty
            drawFromBoneyard() {
                if (this.boneyard.length > 0) {
                    return this.boneyard.pop();
                }
                return null;
            }

            // Returns array of {domino, placements} objects for playable tiles
            getPlayableDominoes(hand) {
                return hand.map(d => ({ domino: d, placements: this.canPlay(d) }))
                           .filter(item => item.placements.length > 0);
            }

            // Checks win/block conditions and sets winner
            checkGameOver() {
                // Check if player won by emptying hand
                if (this.playerHand.length === 0) {
                    this.gameOver = true;
                    this.winner = "Player";
                    return true;
                }
                // Check if AI won by emptying hand
                if (this.aiHand.length === 0) {
                    this.gameOver = true;
                    this.winner = "AI";
                    return true;
                }

                // Check if game is blocked (neither can play)
                const playerCanPlay = this.getPlayableDominoes(this.playerHand).length > 0;
                const aiCanPlay = this.getPlayableDominoes(this.aiHand).length > 0;

                if (!playerCanPlay && !aiCanPlay && this.boneyard.length === 0) {
                    this.gameOver = true;
                    // Winner has lowest total
                    const playerTotal = this.playerHand.reduce((sum, d) => sum + d.total(), 0);
                    const aiTotal = this.aiHand.reduce((sum, d) => sum + d.total(), 0);

                    if (playerTotal < aiTotal) {
                        this.winner = "Player";
                    } else if (aiTotal < playerTotal) {
                        this.winner = "AI";
                    } else {
                        this.winner = "Tie";
                    }
                    return true;
                }
                return false;
            }
        }

        // ============================================
        // AI CLASS - Simple AI opponent strategy
        // ============================================
        class DominoAI {
            constructor(game) {
                this.game = game;
            }

            // Returns best move as {domino, side} or null if must draw
            chooseMove() {
                const playable = this.game.getPlayableDominoes(this.game.aiHand);
                if (playable.length === 0) return null;

                // Strategy: prioritize doubles, then highest scoring tiles
                const doubles = playable.filter(p => p.domino.isDouble());
                let chosen;
                if (doubles.length > 0) {
                    chosen = doubles.reduce((a, b) => a.domino.total() > b.domino.total() ? a : b);
                } else {
                    chosen = playable.reduce((a, b) => a.domino.total() > b.domino.total() ? a : b);
                }

                return { domino: chosen.domino, side: chosen.placements[0] };
            }
        }

        // ============================================
        // GAME STATE AND DOM ELEMENTS
        // ============================================
        let game = new DominoGame();
        let ai = new DominoAI(game);
        let selectedDomino = null;  // Currently selected tile by player

        const statusEl = document.getElementById('status');
        const aiHandEl = document.getElementById('ai-hand');
        const boardEl = document.getElementById('board');
        const boardInfoEl = document.getElementById('board-info');
        const playerHandEl = document.getElementById('player-hand');
        const boneyardInfoEl = document.getElementById('boneyard-info');
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnDraw = document.getElementById('btn-draw');
        const winnerOverlay = document.getElementById('winner-overlay');
        const winnerTitle = document.getElementById('winner-title');
        const winnerScores = document.getElementById('winner-scores');

        // ============================================
        // UI FUNCTIONS
        // ============================================

        // Creates a visual domino element
        function createDominoElement(domino, options = {}) {
            const { hidden = false, clickable = false, selected = false } = options;

            const el = document.createElement('div');
            el.className = 'domino';
            if (hidden) el.classList.add('hidden');
            if (domino && domino.isDouble()) el.classList.add('double');
            if (clickable) el.classList.add('clickable');
            if (selected) el.classList.add('selected');

            // Create left half
            const leftHalf = document.createElement('div');
            leftHalf.className = 'domino-half';
            leftHalf.textContent = hidden ? '?' : domino.left;

            // Create divider line
            const divider = document.createElement('div');
            divider.className = 'domino-divider';

            // Create right half
            const rightHalf = document.createElement('div');
            rightHalf.className = 'domino-half';
            rightHalf.textContent = hidden ? '?' : domino.right;

            el.appendChild(leftHalf);
            el.appendChild(divider);
            el.appendChild(rightHalf);

            // Add click handler if clickable
            if (clickable && !hidden) {
                el.addEventListener('click', () => selectDomino(domino));
            }

            return el;
        }

        // Handles player selecting a domino
        function selectDomino(domino) {
            if (!game.playerTurn || game.gameOver) return;

            selectedDomino = domino;
            updateDisplay();

            // Enable/disable play buttons based on valid placements
            const placements = game.canPlay(domino);
            btnLeft.disabled = !placements.includes('left');
            btnRight.disabled = !placements.includes('right');

            if (placements.length > 0) {
                statusEl.textContent = `Selected ${domino} - Choose where to play`;
            } else {
                statusEl.textContent = `Selected ${domino} - Cannot play this tile!`;
            }
        }

        // Plays the selected domino on specified side
        function playSelected(side) {
            if (!selectedDomino || !game.playerTurn) return;

            if (game.playDomino(selectedDomino, side)) {
                // Remove from player's hand
                const idx = game.playerHand.findIndex(d => d.equals(selectedDomino));
                if (idx !== -1) game.playerHand.splice(idx, 1);

                selectedDomino = null;
                btnLeft.disabled = true;
                btnRight.disabled = true;

                // Check if game ended
                if (game.checkGameOver()) {
                    endGame();
                } else {
                    // Switch to AI turn
                    game.playerTurn = false;
                    updateDisplay();
                    statusEl.textContent = "AI is thinking...";
                    setTimeout(aiTurn, 800);
                }
            }
        }

        // Handles player drawing from boneyard
        function drawTile() {
            if (!game.playerTurn || game.gameOver) return;

            // Don't allow draw if player has playable tiles
            if (game.getPlayableDominoes(game.playerHand).length > 0) {
                statusEl.textContent = "You have playable tiles! Select one.";
                return;
            }

            const domino = game.drawFromBoneyard();
            if (domino) {
                game.playerHand.push(domino);
                statusEl.textContent = `Drew ${domino}`;
                updateDisplay();

                // If still no playable tiles and boneyard empty, pass turn
                if (game.getPlayableDominoes(game.playerHand).length === 0) {
                    if (game.boneyard.length === 0) {
                        statusEl.textContent = "No playable tiles - passing turn";
                        game.playerTurn = false;
                        if (game.checkGameOver()) {
                            endGame();
                        } else {
                            setTimeout(aiTurn, 800);
                        }
                    }
                }
            } else {
                // Boneyard empty, must pass
                statusEl.textContent = "Boneyard empty - passing turn";
                game.playerTurn = false;
                if (game.checkGameOver()) {
                    endGame();
                } else {
                    setTimeout(aiTurn, 800);
                }
            }
        }

        // Executes AI's turn
        function aiTurn() {
            if (game.gameOver) return;

            game.playerTurn = false;
            updateDisplay();

            const move = ai.chooseMove();

            if (move) {
                // AI has a playable tile
                game.playDomino(move.domino, move.side);
                const idx = game.aiHand.findIndex(d => d.equals(move.domino));
                if (idx !== -1) game.aiHand.splice(idx, 1);
                statusEl.textContent = `AI played ${move.domino} on ${move.side}`;
            } else {
                // AI must draw until playable tile or boneyard empty
                let drewPlayable = false;
                while (game.boneyard.length > 0) {
                    const domino = game.drawFromBoneyard();
                    game.aiHand.push(domino);
                    const placements = game.canPlay(domino);
                    if (placements.length > 0) {
                        // Found playable tile, play it immediately
                        game.playDomino(domino, placements[0]);
                        const idx = game.aiHand.findIndex(d => d.equals(domino));
                        if (idx !== -1) game.aiHand.splice(idx, 1);
                        statusEl.textContent = `AI drew and played ${domino}`;
                        drewPlayable = true;
                        break;
                    }
                }
                if (!drewPlayable) {
                    statusEl.textContent = "AI passed (no playable tiles)";
                }
            }

            // Check for game over, otherwise pass to player
            if (game.checkGameOver()) {
                endGame();
            } else {
                game.playerTurn = true;
                updateDisplay();
                const playable = game.getPlayableDominoes(game.playerHand);
                if (playable.length > 0) {
                    statusEl.textContent = "Your turn - Select a domino";
                } else {
                    // Player has no playable tiles
                    if (game.boneyard.length > 0) {
                        statusEl.textContent = "No playable tiles - Draw from boneyard";
                    } else {
                        // Player must pass, continue with AI
                        statusEl.textContent = "No playable tiles and boneyard empty - passing";
                        game.playerTurn = false;
                        setTimeout(() => {
                            if (game.checkGameOver()) {
                                endGame();
                            } else {
                                aiTurn();
                            }
                        }, 800);
                    }
                }
            }
        }

        // Updates all visual elements to match game state
        function updateDisplay() {
            // Render AI hand (hidden tiles)
            aiHandEl.innerHTML = '';
            game.aiHand.forEach(d => {
                aiHandEl.appendChild(createDominoElement(d, { hidden: true }));
            });

            // Render board
            boardEl.innerHTML = '';
            if (game.board.length > 0) {
                boardInfoEl.textContent = `Left end: ${game.leftEnd}  |  Right end: ${game.rightEnd}`;
                game.board.forEach(d => {
                    boardEl.appendChild(createDominoElement(d));
                });
            } else {
                boardInfoEl.textContent = "Board is empty - Play first domino";
            }

            // Render player hand (clickable during their turn)
            playerHandEl.innerHTML = '';
            game.playerHand.forEach(d => {
                const isSelected = selectedDomino && d.equals(selectedDomino);
                playerHandEl.appendChild(createDominoElement(d, {
                    clickable: game.playerTurn,
                    selected: isSelected
                }));
            });

            // Update boneyard counter
            boneyardInfoEl.textContent = `Boneyard: ${game.boneyard.length} tiles remaining`;

            // Enable/disable draw button
            btnDraw.disabled = !game.playerTurn;
        }

        // Displays game over screen with results
        function endGame() {
            updateDisplay();

            const playerScore = game.playerHand.reduce((sum, d) => sum + d.total(), 0);
            const aiScore = game.aiHand.reduce((sum, d) => sum + d.total(), 0);

            if (game.winner === "Tie") {
                winnerTitle.textContent = "It's a Tie!";
            } else if (game.winner === "Player") {
                winnerTitle.textContent = "ðŸŽ‰ You Win!";
            } else {
                winnerTitle.textContent = "AI Wins!";
            }

            winnerScores.innerHTML = `Your remaining: ${playerScore}<br>AI remaining: ${aiScore}`;
            winnerOverlay.classList.remove('hidden-overlay');
        }

        // Resets game to initial state
        function newGame() {
            game = new DominoGame();
            ai = new DominoAI(game);
            selectedDomino = null;
            btnLeft.disabled = true;
            btnRight.disabled = true;
            winnerOverlay.classList.add('hidden-overlay');
            updateDisplay();

            if (game.playerTurn) {
                statusEl.textContent = "Your turn - Select a domino";
            } else {
                statusEl.textContent = "AI goes first...";
                setTimeout(aiTurn, 1000);
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        updateDisplay();
        if (!game.playerTurn) {
            statusEl.textContent = "AI goes first...";
            setTimeout(aiTurn, 1000);
        }
    </script>
</body>
</html>
